<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://jrhlive.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="深入理解动态代理来源 一、概述最近在阅读retrofit源码时,有个关键的所在就是动态代理，细细回想了一下动态代理,发现之前有些细节还没有理解到位，本篇博文将重新深入理解一下动态代理。">
<meta name="keywords" content="java,android">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解动态代理">
<meta property="og:url" content="http://jrhlive.com/2019/09/25/深入理解动态代理/index.html">
<meta property="og:site_name" content="STAY HUNGRY. STAY FOOLISH.">
<meta property="og:description" content="深入理解动态代理来源 一、概述最近在阅读retrofit源码时,有个关键的所在就是动态代理，细细回想了一下动态代理,发现之前有些细节还没有理解到位，本篇博文将重新深入理解一下动态代理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d98d4237?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9a53c4a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9bb2a1a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2019-12-31T06:47:17.451Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解动态代理">
<meta name="twitter:description" content="深入理解动态代理来源 一、概述最近在阅读retrofit源码时,有个关键的所在就是动态代理，细细回想了一下动态代理,发现之前有些细节还没有理解到位，本篇博文将重新深入理解一下动态代理。">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d98d4237?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">

<link rel="canonical" href="http://jrhlive.com/2019/09/25/深入理解动态代理/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>深入理解动态代理 | STAY HUNGRY. STAY FOOLISH.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">STAY HUNGRY. STAY FOOLISH.</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Hi,sweet.A new day.</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/09/25/深入理解动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解动态代理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-25 20:50:20" itemprop="dateCreated datePublished" datetime="2019-09-25T20:50:20+08:00">2019-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:47:17" itemprop="dateModified" datetime="2019-12-31T14:47:17+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id><a href="#" class="headerlink" title></a></h2><h1 id="深入理解动态代理"><a href="#深入理解动态代理" class="headerlink" title="深入理解动态代理"></a>深入理解动态代理</h1><p><a href="https://juejin.im/post/5c70094051882562a12aec51" target="_blank" rel="noopener">来源</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>最近在阅读retrofit源码时,有个关键的所在就是动态代理，细细回想了一下动态代理,发现之前有些细节还没有理解到位，本篇博文将重新深入理解一下动态代理。</p>
<a id="more"></a>

<h1 id="二、关于代理"><a href="#二、关于代理" class="headerlink" title="二、关于代理"></a>二、关于代理</h1><p>中华名族是一个含蓄的名族，讲究微妙和间接的交流方式。对象之间的间接通信也是同样是面向对象设计中一条重要的审美观，迪米特法则也指出“一个对象应该对其他对象保持最少的了解”,间接间通信可以达到“高内聚，低耦合”的效果。<br>代理是一种重要的手段之一，比如生活中的微商代理，厂家委托其代理销售商品，我们只跟微商打交道，不知道背后的“厂家是谁”，微商和厂家就可以抽象为 “代理类”和“委托类”，这样就可以，隐藏委托类的实现、实现客户与委托类之间的解耦，可以不用修改委托类的情况下做一些额外的处理</p>
<h2 id="2-1、代理模式简介"><a href="#2-1、代理模式简介" class="headerlink" title="2.1、代理模式简介"></a>2.1、代理模式简介</h2><p>在《Java与模式》一书中指出”代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的访问”，类图如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d98d4237?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<p>通过类图可以发现，代理模式的代理对象<code>Proxy</code>和目标对象<code>Subject</code>实现同一个接口，客户调用的是<code>Proxy</code>对象，<code>Proxy</code>可以控制<code>Subject</code>的访问，真正的功能实现是在<code>Subject</code>完成的。</p>
<p>适用场景:</p>
<ul>
<li>不希望某些类被直接访问。</li>
<li>访问之前希望先进行一些预处理。</li>
<li>希望对被访问的对象进行内存、权限等方面的控制。</li>
</ul>
<p>优点如下</p>
<ul>
<li>代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。</li>
<li>代理模式主要用于远程代理、虚拟代理和保护代理。其中保护代理可以进行访问权限控制。</li>
</ul>
<h2 id="2-2、静态代理"><a href="#2-2、静态代理" class="headerlink" title="2.2、静态代理"></a>2.2、静态代理</h2><p>“静态”代理，若代理类在程序运行前已经存在，这种通常称为静态代理，比如微商A只代理A品牌的面膜,消费者通过微商才能买到某厂的面膜(控制权)，其中微商和工厂都实现了了Sell的接口</p>
<blockquote>
<p>委托类面膜工厂</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class  FactoryOne :SellMask&#123;</span><br><span class="line">    override fun sell() &#123;</span><br><span class="line">        println(&quot;FactoryOne: 来自工厂A的面膜&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>微商静态代理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class BusinessAgent : SellMask &#123;</span><br><span class="line">    private lateinit var sellMask: SellMask</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        sellMask = FactoryOne()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun sell() &#123;</span><br><span class="line">        println(&quot;BusinessAgent: 微商代理开始在朋友圈打广告&quot;)</span><br><span class="line">        sellMask.sell()</span><br><span class="line">        print(&quot;BusinessAgent: 赚了一大把&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>共同接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SellMask &#123;</span><br><span class="line">    fun sell()</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="2-3、相似模式的比较"><a href="#2-3、相似模式的比较" class="headerlink" title="2.3、相似模式的比较"></a>2.3、相似模式的比较</h2><p>既然获得引用就可以做一些扩展之类的事情，这点跟装饰者模式、适配器模式看起来很像，三者都属于结构型模式，但是代理模式核心是为其它对象提供一种代理以控制对这个对象的访问()</p>
<blockquote>
<p>代理模式 VS 适配器模式</p>
</blockquote>
<p>看上去很像，它们都可视为一个对象提供一种前置的接口，但是适配器模式的用意是改变所考虑的对象的接口，而代理模式并不能改变所代理的对象的接口，这一点上两个模式有着明显的区别，下图分别是 对象适配器和类的适配器UML图</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9a53c4a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<blockquote>
<p>代理模式VS 装饰模式</p>
</blockquote>
<p>装饰者模式与所装饰的对象有着相同的接口，这一点跟代理模式相同，但是装饰模式更强调为所装饰的对象提供增强功能，而代理模式则是对对象的使用施加控制，并不提供对象本身的增强功能；被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象由客户端创建并传给装饰对象。装饰者UML图如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9bb2a1a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<p>你以为这就完了吗？下面👇才是重头戏！</p>
<h1 id="三、深入理解动态代理"><a href="#三、深入理解动态代理" class="headerlink" title="三、深入理解动态代理"></a>三、深入理解动态代理</h1><h2 id="3-1、什么是动态代理"><a href="#3-1、什么是动态代理" class="headerlink" title="3.1、什么是动态代理"></a>3.1、什么是动态代理</h2><p>代理类在程序运行时创建的代理方式被成为 动态代理。即代理类并不是在代码中定义的，而是在运行时根据我们在Java代码中”规定”的信息自动生成。静态代理容易造成代码的膨胀，。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 还是以上面的卖面膜微商为例，她在进货市场进行一番比较之后再决定代理哪个品牌的面膜。</p>
<h2 id="3-2、如何使用动态代理"><a href="#3-2、如何使用动态代理" class="headerlink" title="3.2、如何使用动态代理"></a>3.2、如何使用动态代理</h2><p>跟上文一样，微商和面膜工厂都实现了sell接口，这里就不赘述了，下面看下与众不同的地方，实现动态代理需要实现InvocationHandler接口</p>
<blockquote>
<p>实现InvocationHandler接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    private Object object;//被引用的代理</span><br><span class="line"></span><br><span class="line">    public Object newProxyInstance(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;代理商 包装发朋友圈&quot;);</span><br><span class="line">        Object result = method.invoke(object,args);</span><br><span class="line">        System.out.println(&quot;代理商 赚钱&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>target 属性表示委托类对象</li>
<li><code>InvocationHandler</code>是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个 invoke函数需要实现</li>
<li>invoke函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面好好看看这个核心函数的参数含义</p>
<ul>
<li>proxy 代通过dynamicproxy.newProxyInstance(business)自动生成的代理类 $Proxy0.class(下文会详细介绍)</li>
<li>method表示代理对象被调用的函数，比如sellMask接口里面的sell方法</li>
<li>args 表示代理大力调用函数的的参数，这里sell方法无参数</li>
</ul>
<p>调用代理对象的每个函数，实际上最终都是走到InvocationHandler的invoke函数，因此可以在这里做一些统一的处理，AOP的雏形就慢慢出现了，我们也可以根据method方法名做一些判断，从而实现对某些函数的特殊处理。</p>
<blockquote>
<p>使用动态代理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;)  //加入这个可以获取代理类</span><br><span class="line"></span><br><span class="line">    var maskFactory = FactoryMaskOne()</span><br><span class="line"></span><br><span class="line">    var dynamicproxy: DynamicProxy = DynamicProxy()</span><br><span class="line"></span><br><span class="line">    var sellMask: SellMask = dynamicproxy.newProxyInstance(maskFactory) as SellMask</span><br><span class="line"></span><br><span class="line">    sellMask.sell()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们将委托类面膜工程FactoryMaskOne传到dynamicproxy.newProxyInstance中，通过下面的函数返回了一个代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object newProxyInstance(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>实际代理类就是在这个时候动态生成的，后续调用到这个代理类的函数就会直接调用invoke函数，让我们细细看下这个Proxy.newProxyInstance</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>法的三个参数含义分别如下：</p>
<ul>
<li>loader：定义了代理类的ClassLoder;</li>
<li>interfaces：代理类实现的接口列表</li>
<li>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例</li>
</ul>
<p>这里简单总结一下，委托类通过*<em>newProxyInstance *</em>方法获取动态生成的代理类的实例(本例是$Proxy0.class),然后可以通过这个代理类实例调用代理的方法获得委托类的控制权，对代理类的调用实际上都会走到invoke方法，在这里我们调用委托类的相应方法，并且可以添加自己的一些逻辑，比如统一处理登陆、校验之类的。</p>
<h2 id="3-3、动态生成的代理类-Proxy0"><a href="#3-3、动态生成的代理类-Proxy0" class="headerlink" title="3.3、动态生成的代理类$Proxy0"></a>3.3、动态生成的代理类$Proxy0</h2><p>在Android Studio中调用不了<code>ProxyGenerator</code>这个类,这个类在sun.misc包中,使用IntelliJ IDE创建java工程，需要看一下<a href="https://juejin.im/post/5c70094051882562a12aec51" target="_blank" rel="noopener">jdk</a>的反射中Proxy和生成的代理类$Proxy0的源码，可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//生成$Proxy0的class文件</span><br><span class="line">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>生成的代理类在com.sun.proxy包里面完整代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public final class $Proxy0 extends Proxy implements SellMask &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    public final void sell() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //可以看到接口方法都交由h的invoke方法处理，h在父类Proxy中定义为InvocationHandler接口</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m3 = Class.forName(&quot;dev.proxy.SellMask&quot;).getMethod(&quot;sell&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从生成的代理类中可以看到</p>
<ul>
<li>动态生成的代理类是以<code>$Proxy</code>为类名前缀，继承自<code>Proxy</code>，并且实现了<code>Proxy.newProxyInstance(…)</code>第二个参数传入的所有接口的类。</li>
<li>接口方法都交由h的invoke方法处理，h在父类Proxy中定义为InvocationHandler接口，为Proxy.newProxyInstance(…)的第三个参数</li>
</ul>
<h2 id="3-4-动态代理类如何生成"><a href="#3-4-动态代理类如何生成" class="headerlink" title="3.4 动态代理类如何生成"></a>3.4 动态代理类如何生成</h2><ul>
<li>关注点1 Proxy.newProxyInstance(……)函数</li>
</ul>
<p>动态代理类是在调用 Proxy.newProxyInstance(……)函数时生成的，精简后的核心代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        ……</span><br><span class="line">        /*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         * 得到动态代理类</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">            ……</span><br><span class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih = h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            //然后将InvocationHandler作为代理类构造函数入参新建代理类对象</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">           ……</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到 首先调用它先调用<code>getProxyClass(loader, interfaces)</code>得到动态代理类，然后将<code>InvocationHandler</code>作为代理类构造函数入参新建代理类对象。</p>
<ul>
<li>关注点2 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</li>
</ul>
<p>如何获取到 生成动态代理类呢，一步步追踪，我们发现，在Proxy#ProxyClassFactory类中，在ProxyGenerator中去生成动态代理，类名以$Proxy+num作为标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">						/*</span><br><span class="line">             * Generate the specified proxy class.</span><br><span class="line">             */</span><br><span class="line">            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line">            try &#123;</span><br><span class="line">                return defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">            &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">                throw new IllegalArgumentException(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇主要java中的代理模式以及跟其他模式的对比，并重点介绍了JDK中的动态代理机制，像AOP、retrofit核心机制之一就使用到了这种技术，但Java动态代理是基于接口的，如果对象没有实现接口我们该如何代理呢？那就需要CGLIB了，<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，这里就不展开赘述了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://juejin.im/post/5a99048a6fb9a028d5668e62" target="_blank" rel="noopener">juejin.im/post/5a9904…</a></li>
<li><a href="https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a" target="_blank" rel="noopener">juejin.im/post/5ad3e6…</a></li>
<li><a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">www.cnblogs.com/xiaoluo5013…</a></li>
<li><a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">www.zhihu.com/question/20…</a></li>
<li><a href="https://blog.csdn.net/qq_27095957/article/details/80184291" target="_blank" rel="noopener">blog.csdn.net/qq_27095957…</a></li>
<li>[a.codekk.com/detail/Andr…](<a href="http://a.codekk.com/detail/Android/Caij/公共技术点之" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/Caij/公共技术点之</a> Java 动态代理)</li>
<li><a href="https://www.jianshu.com/p/0391a8e93d3d" target="_blank" rel="noopener">www.jianshu.com/p/0391a8e93…</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/android/" rel="tag"># android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/23/设计模式精简图册/" rel="prev" title="设计模式精简图册">
      <i class="fa fa-chevron-left"></i> 设计模式精简图册
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/10/02/ArrayList使用笔记/" rel="next" title="ArrayList使用笔记">
      ArrayList使用笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入理解动态代理"><span class="nav-number"></span> <span class="nav-text">深入理解动态代理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、概述"><span class="nav-number"></span> <span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、关于代理"><span class="nav-number"></span> <span class="nav-text">二、关于代理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1、代理模式简介"><span class="nav-number">1.</span> <span class="nav-text">2.1、代理模式简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2、静态代理"><span class="nav-number">2.</span> <span class="nav-text">2.2、静态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3、相似模式的比较"><span class="nav-number">3.</span> <span class="nav-text">2.3、相似模式的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、深入理解动态代理"><span class="nav-number"></span> <span class="nav-text">三、深入理解动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1、什么是动态代理"><span class="nav-number">1.</span> <span class="nav-text">3.1、什么是动态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2、如何使用动态代理"><span class="nav-number">2.</span> <span class="nav-text">3.2、如何使用动态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3、动态生成的代理类-Proxy0"><span class="nav-number">3.</span> <span class="nav-text">3.3、动态生成的代理类$Proxy0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-动态代理类如何生成"><span class="nav-number">4.</span> <span class="nav-text">3.4 动态代理类如何生成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number"></span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考链接"><span class="nav-number"></span> <span class="nav-text">参考链接</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiarh</p>
  <div class="site-description" itemprop="description">coding change the world .</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiarh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
