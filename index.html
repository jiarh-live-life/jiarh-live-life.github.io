<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://jrhlive.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="coding change the world .">
<meta name="keywords" content="jrhlive jrhlife livelife live-life ailife ailive smart-live  stmart-life">
<meta property="og:type" content="website">
<meta property="og:title" content="STAY HUNGRY. STAY FOOLISH.">
<meta property="og:url" content="http://jrhlive.com/index.html">
<meta property="og:site_name" content="STAY HUNGRY. STAY FOOLISH.">
<meta property="og:description" content="coding change the world .">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STAY HUNGRY. STAY FOOLISH.">
<meta name="twitter:description" content="coding change the world .">

<link rel="canonical" href="http://jrhlive.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>STAY HUNGRY. STAY FOOLISH.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">STAY HUNGRY. STAY FOOLISH.</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Hi,sweet.A new day.</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/31/adb-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/adb-shell/" class="post-title-link" itemprop="url">adb shell</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-31 14:14:26 / 修改时间：14:29:24" itemprop="dateCreated datePublished" datetime="2019-12-31T14:14:26+08:00">2019-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/mzlogin/awesome-adb" target="_blank" rel="noopener">文章来源</a></p>
<p>[TOC]</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><p>adb 命令的基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;</span><br></pre></td></tr></table></figure>

<p>如果只有一个设备/模拟器连接时，可以省略掉 <code>[-d|-e|-s ]</code> 这一部分，直接使用 <code>adb</code>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/31/adb-shell/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/31/性能优化/性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/性能优化/性能优化/" class="post-title-link" itemprop="url">性能优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-31 14:07:07 / 修改时间：14:32:06" itemprop="dateCreated datePublished" datetime="2019-12-31T14:07:07+08:00">2019-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="App优化"><a href="#App优化" class="headerlink" title="App优化"></a>App优化</h2><ol>
<li><p>app 启动优化（视觉体验优化）</p>
<ul>
<li>白屏、黑屏问题？(不会缩短实际冷启动时间)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".base.App"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppThemeBase"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br></pre></td></tr></table></figure>

<p>styles.xml 增加一个主题叫AppThemeBase</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppThemeBase"</span> <span class="attr">parent</span>=<span class="string">"XUITheme.Phone"</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--  设置启动白屏的图片背景 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/theme_bg<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/31/性能优化/性能优化/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/31/android自定义View/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/android自定义View/" class="post-title-link" itemprop="url">android自定义View</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-31 14:01:02 / 修改时间：14:30:19" itemprop="dateCreated datePublished" datetime="2019-12-31T14:01:02+08:00">2019-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android自定义View"><a href="#Android自定义View" class="headerlink" title="Android自定义View"></a>Android自定义View</h2><blockquote>
<p>根据需求整合几个控件，使用</p>
<p>扩展或者更改原始控件的功能逻辑</p>
<p>实现一些无法用原始控件实现的布局，或简化布局复杂程度，提高性能</p>
</blockquote>
<ul>
<li><p>布局</p>
</li>
<li><p>绘制</p>
</li>
<li><p>触摸反馈</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/31/android自定义View/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/31/Android-触摸事件-事件分发机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/Android-触摸事件-事件分发机制/" class="post-title-link" itemprop="url">Android 触摸事件&&事件分发机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-31 13:58:55 / 修改时间：14:30:34" itemprop="dateCreated datePublished" datetime="2019-12-31T13:58:55+08:00">2019-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android-触摸事件"><a href="#Android-触摸事件" class="headerlink" title="Android 触摸事件"></a>Android 触摸事件</h2><blockquote>
<p>触摸反馈的本质就是把一系列的触摸反馈解读为对应的事件。</p>
<p>比如：点击，按下移动，抬起</p>
<p>触摸事件不是独立的，是成组出现。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/31/Android-触摸事件-事件分发机制/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/31/Android-新技术盘点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/Android-新技术盘点/" class="post-title-link" itemprop="url">Android 新技术盘点</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-31 10:37:57 / 修改时间：14:32:56" itemprop="dateCreated datePublished" datetime="2019-12-31T10:37:57+08:00">2019-12-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-技术盘点"><a href="#Android-技术盘点" class="headerlink" title="Android 技术盘点"></a>Android 技术盘点</h1><ol>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652051133&idx=1&sn=9b16cf47ab541912d2087c2462d9953f&scene=21#wechat_redirect" target="_blank" rel="noopener">预览版 Jetpack Compose</a>: 一款面向未来 10 年推出的现代声明式 UI 工具包。</p>
<blockquote>
<p>得益于 Kotlin 的启发，Compose 允许您使用更加直观、简洁的代码构建精美的原生应用。</p>
</blockquote>
</li>
<li><p>Android Jetpack 发布了许多稳定版开发库，其中包括用于调度后台任务的 WorkManager、用于进行应用内导航的 Navigation、以及用于分析应用性能的基准库。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/31/Android-新技术盘点/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/30/探索 Java 内存管理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/30/探索 Java 内存管理机制/" class="post-title-link" itemprop="url">探索 Java 内存管理机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-30 20:22:20" itemprop="dateCreated datePublished" datetime="2019-12-30T20:22:20+08:00">2019-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:27:59" itemprop="dateModified" datetime="2019-12-31T14:27:59+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="探索-Java-内存管理机制"><a href="#探索-Java-内存管理机制" class="headerlink" title="探索 Java 内存管理机制"></a>探索 Java 内存管理机制</h1><p><a href="https://juejin.im/post/5d3a870df265da1b855c9d41" target="_blank" rel="noopener">来源</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/26/16c2c9fa9f1d2480?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="首图.jpg"></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>什么是内存？</li>
<li>什么是 Java 内存模型？</li>
<li>什么是 JVM？</li>
<li>JVM 是怎么划分内存的？</li>
<li>栈帧中的数据有什么用？</li>
<li>什么是可达性算法？</li>
<li>Java 中有哪几种引用？</li>
<li>什么是垃圾回收器？</li>
<li>参考文献</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/30/探索 Java 内存管理机制/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/29/探索 Android 内存优化方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/29/探索 Android 内存优化方法/" class="post-title-link" itemprop="url">探索 Android 内存优化方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 22:50:20" itemprop="dateCreated datePublished" datetime="2019-12-29T22:50:20+08:00">2019-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:25:05" itemprop="dateModified" datetime="2019-12-31T14:25:05+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="探索-Android-内存优化方法"><a href="#探索-Android-内存优化方法" class="headerlink" title="探索 Android 内存优化方法"></a>探索 Android 内存优化方法</h1><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc" target="_blank" rel="noopener">来源</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/26/16c2de38e6eae104?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="首图.jpg"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/29/16c3bf56cf1088f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="目录"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章的内容是我回顾和再学习 Android 内存优化的过程中整理出来的，整理的目的是让我自己对 Android 内存优化相关知识的认识更全面一些，分享的目的是希望大家也能从这些知识中得到一些启发。</p>
<p>Android 应用运行在 ART 环境上，ART 是基于 JVM 优化而来的，ART 优化的目标就是为了让 Android 应用能更高效地在 Android 平台运行。</p>
<p>不严谨地说，Android 应用就是一个在 Android 平台运行良好的 Java 程序，承载着 Android 应用的 ActivityThread 同样有 main 方法。</p>
<p>因此只有了解了 Java 的内存管理机制，才能更好地理解 Android 的内存管理机制，如果你对这一块还不熟悉的话，可以看我的上一篇文章 <a href="https://juejin.im/post/5d3a870df265da1b855c9d41" target="_blank" rel="noopener">探索 Java 内存管理机制</a>。</p>
<p>本文的内容可分为下面两部分，大家可以根据自己的需要选择性地阅读。</p>
<ul>
<li><p>第一部分</p>
<p>第一部分讲的是 Android 内存管理机制相关的一些知识，包括 Dalvik 虚拟机和 ART 环境等。</p>
</li>
<li><p>第二部分</p>
<p>第二部分讲的是内存问题的解决与优化方法，包括 Memory Profiler、MAT 等工具的使用方法。</p>
</li>
</ul>
<h2 id="1-为什么要做内存优化？"><a href="#1-为什么要做内存优化？" class="headerlink" title="1. 为什么要做内存优化？"></a>1. 为什么要做内存优化？</h2><p><strong>内存优化能让应用挂得少、活得好和活得久</strong>。</p>
<ul>
<li><p>挂得少</p>
<p>“挂”指的是 Crash，假如一个满分的应用是 100 分，那么一个会 Crash 的应用在用户心里会扣掉 90 分。</p>
<p>就像是我们在一家店吃到了一盘很难吃的小龙虾，哪怕别人说这家店再好吃，我们以后都不想吃这家店了。</p>
<p>导致 Android 应用 Crash 的原因有很多种，而做内存优化就能让我们的应用避免由内存问题引起的 Crash。</p>
<p>内存问题导致 Crash 的具体表现就是内存溢出异常 OOM，引起 OOM 的原因有多种，在后面我会对它们做一个更详细的介绍。</p>
</li>
<li><p>活得好</p>
<p>活得好指的是使用流畅，Android 中造成界面卡顿的原因有很多种，其中一种就是由内存问题引起的。</p>
<p>内存问题之所以会影响到界面流畅度，是因为垃圾回收（GC，Garbage Collection），在 GC 时，所有线程都要停止，包括主线程，当 GC 和绘制界面的操作同时触发时，绘制的执行就会被搁置，导致掉帧，也就是界面卡顿。</p>
<p>关于 GC 的更多介绍，可以看我的上一篇文章。</p>
</li>
<li><p>活得久</p>
<p>活得久指的是我们的应用在后台运行时不会被干掉。</p>
<p>Android 会按照特定的机制清理进程，清理进程时优先会考虑清理后台进程。</p>
<p>清理进程的机制就是低杀，关于低杀在后面会有更详细的介绍。</p>
<p>假如现在有个用户小张想在我们的电商应用买一个商品，千辛万苦挑到了一个自己喜欢的商品后，当他准备购买时，小张的老婆叫他去给孩子换尿布，等小张再打开应用时，发现商品页已经被关闭了，也就是应用被干掉了，这时小张又想起了孩子的奶粉钱，可能就放弃这次购买了。</p>
<p>用户在移动设备上使用应用的过程中被打断是很常见的，如果我们的应用不能活到用户回来的时候，要用户再次进行操作的体验就会很差。</p>
</li>
</ul>
<h2 id="2-什么是-Dalvik？"><a href="#2-什么是-Dalvik？" class="headerlink" title="2. 什么是 Dalvik？"></a>2. 什么是 Dalvik？</h2><p>要了解 Android 应用的内存管理机制，就要了解承载着 Android 应用的虚拟机 Dalvik，虽然 Android 现在是使用的 ART 来承载应用的执行，但是 ART 也是基于 Dalvik 优化而来的。</p>
<p>Dalvik 是 Dalvik Virtual Machine（Dalvik 虚拟机）的简称，是 Android 平台的核心组成部分之一，Dalvik 与 JVM 的区别有如下几个。</p>
<h3 id="2-1-Dalvik-与-JVM-的区别"><a href="#2-1-Dalvik-与-JVM-的区别" class="headerlink" title="2.1 Dalvik 与 JVM 的区别"></a>2.1 Dalvik 与 JVM 的区别</h3><ul>
<li><p>架构</p>
<p>JVM 是基于栈的，也就是需要在栈中读取数据，所需的指令会更多，这样会导致速度慢，不适合性能优先的移动设备。</p>
<p>Dalvik 是基于寄存器的，指令更紧凑和简洁。</p>
<p>由于显式指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数的减少，总的代码数不会增加多少。</p>
</li>
<li><p>执行代码不同</p>
<p>在 Java SE 程序中，Java 类会被编译成一个或多个 .class 文件，然后打包成 jar 文件，JVM 会通过对应的 .class 文件和 jar 文件获取对应的字节码。</p>
<p>而 Dalvik 会用 dx 工具将所有的 .class 文件转换为一个 .dex 文件，然后会从该 .dex 文件读取指令和数据。</p>
</li>
</ul>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="612" height="379"/>)</p>
<ul>
<li><p>Zygote</p>
<p>Dalvik 由 Zygote 孵化器创建，Zygote 本身也是一个 Dalvik VM 进程，当系统需要创建一个进程时，Zygote 就会进行 fork，快速创建和初始化一个 DVM 实例。</p>
<p>对于一些只读的系统库，所有的 Dalvik 实例都能和 Zygote 共享一块内存区域，这样能节省内存开销。</p>
</li>
<li><p>有限内存运行多进程</p>
<p>在 Androd 中，每一个应用都运行在一个 Dalvik VM 实例中，每一个 Dalvik VM 都运行在一个独立的进程空间，这种机制使得 Dalvik 运行在有限的内存中同时运行多个进程。</p>
</li>
<li><p>共享机制</p>
<p>Dalvik 拥有预加载—共享机制，不同应用之间在运行时可以共享相同的类，拥有更高的效率。</p>
<p>而 JVM 不存在这种共享机制，不同的程序，打包后的程序都是彼此独立的，即使包中使用了同样的类，运行时也是单独加载和运行的，无法进行共享。</p>
</li>
<li><p>不是 JVM</p>
<p>Dalvik 不是 Java 虚拟机，它并不是按照 Java 虚拟机规范实现的，两者之间并不兼容。</p>
</li>
</ul>
<h3 id="2-2-Dalvik-堆大小"><a href="#2-2-Dalvik-堆大小" class="headerlink" title="2.2 Dalvik 堆大小"></a>2.2 Dalvik 堆大小</h3><p>每一个手机厂商都可以设定设备中每一个进程能够使用的堆大小，有关进程堆大小的值有下面三个。</p>
<ol>
<li><p>dalvik.vm.heapstartsize</p>
<p>堆分配的初始值大小，这个值越小，系统内存消耗越慢，但是当应用扩展这个堆，导致 GC 和堆调整时，应用会变慢。</p>
<p>这个值越大，应用越流畅，但是可运行的应用也会相对减少。</p>
</li>
<li><p>dalvik.vm.heapgrowthlimit</p>
<p>如果在清单文件中声明 largeHeap 为 true，则 App 使用的内存到 heapsize 才会 OOM，否则达到 heapgrowthlimit 就会 OOM。</p>
</li>
<li><p>dalvik.vm.heapsize</p>
<p>进程可用的堆内存最大值，一旦应用申请的内存超过这个值，就会 OOM。</p>
</li>
</ol>
<p>假如我们想看其中的一个值，我们可以通过命令查看，比如下面这条命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   adb shell getprop dalvik.vm.heapsize</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="3-什么是-ART？"><a href="#3-什么是-ART？" class="headerlink" title="3. 什么是 ART？"></a>3. 什么是 ART？</h2><p>ART 的全称是 Android Runtime，是从 Android 4.4 开始新增的<strong>应用运行时环境</strong>，用于替代 Dalvik 虚拟机。</p>
<p>Dalvik VM 和 ART 都可以支持已转换为 .dex（Dalvik Executable）格式的 Java 应用程序的运行。</p>
<p>ART 与 Dalvik 的区别有下面几个。</p>
<ul>
<li><p>预编译</p>
<p>Dalvik 中的应用每次运行时，字节码都需要通过即时编译器 JIT 转换为机器码，这会使得应用的运行效率降低。</p>
<p>在 ART 中，系统在安装应用时会进行一次预编译，将字节码预先编译成机器码并存储在本地，这样应用就不用在每次运行时执行编译了，运行效率也大大提高。</p>
</li>
<li><p>GC</p>
<p>在 Dalvik 采用的垃圾回收算法是标记-清除算法，启动垃圾回收机制会造成两次暂停（一次在遍历阶段，另一次在标记阶段）。</p>
<p>而在 ART 下，GC 速度比 Dalvik 要快，这是因为应用本身做了垃圾回收的一些工作，启动 GC 后，不再是两次暂停，而是一次暂停。</p>
<p>而且 ART 使用了一种新技术（packard pre-cleaning），在暂停前做了许多事情，减轻了暂停时的工作量。</p>
</li>
<li><p>64 位</p>
<p>Dalvik 是为 32 位 CPU 设计的，而 ART 支持 64 位并兼容 32 位 CPU，这也是 Dalvik 被淘汰的主要原因。</p>
</li>
</ul>
<h2 id="4-什么是低杀？"><a href="#4-什么是低杀？" class="headerlink" title="4. 什么是低杀？"></a>4. 什么是低杀？</h2><h3 id="4-1-低杀简介"><a href="#4-1-低杀简介" class="headerlink" title="4.1 低杀简介"></a>4.1 低杀简介</h3><p>在 Android 中有一个心狠手辣的杀手，要想让我们的应用活下来，就要在开发应用时格外小心。</p>
<p>不过我们也不用太担心，因为它只杀“坏蛋”，只要我们不使坏，那它就不会对我们下手。</p>
<p>这个杀手叫低杀，它的全名是 Low Memory Killer。</p>
<p>低杀跟垃圾回收器 GC 很像，GC 的作用是保证应用有足够的内存可以使用，而低杀的作用是保证系统有足够的内存可以使用。</p>
<p>GC 会按照引用的强度来回收对象，而低杀会按照进程的优先级来回收资源，在这里进程优先级就相当于是应用被用户“引用”的强度。</p>
<p>下面我们就来看看 Android 中的几种进程优先级。</p>
<h3 id="4-2-进程优先级"><a href="#4-2-进程优先级" class="headerlink" title="4.2 进程优先级"></a>4.2 进程优先级</h3><p>在 Android 中不同的进程有着不同的优先级，当两个进程的优先级相同时，低杀会优先考虑干掉消耗内存更多的进程。</p>
<p>也就是如果我们应用占用的内存比其他应用少，并且处于后台时，我们的应用能在后台活下来，这也是内存优化为我们应用带来竞争力的一个直接体现。</p>
<h4 id="4-2-1-前台进程"><a href="#4-2-1-前台进程" class="headerlink" title="4.2.1 前台进程"></a>4.2.1 前台进程</h4><p>前台进程（Foreground Process）是优先级最高的进程，是正在于用户交互的进程，如果满足下面一种情况，则一个进程被认为是前台进程。</p>
<ol>
<li><p>Activity</p>
<p>进程持有一个与用户交互的 Activity（该 Activity 的 onResume 方法被调用）</p>
</li>
<li><p>进程持有一个 Service，并且这个 Service 处于下面几种状态之一</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> * Service 与用户正在交互的 Activity 绑定</span><br><span class="line"> * Service 调用了 startForeground() 方法</span><br><span class="line"> * Service 正在执行以下生命周期函数（onCreate、onStart、onDestroy ）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li><p>BroadcastReceiver</p>
<p>进程持有一个 BroadcastReceiver，这个 BroadcastReceiver 正在执行它的 onReceive() 方法</p>
</li>
</ol>
<h4 id="4-2-2-可见进程"><a href="#4-2-2-可见进程" class="headerlink" title="4.2.2 可见进程"></a>4.2.2 可见进程</h4><p>可见进程（Visible Process）不含有任何前台组件，但用户还能再屏幕上看见它，当满足一下任一条件时，进程被认定是可见进程。</p>
<ol>
<li><p>Activity</p>
<p>进程持有一个 Activity，这个 Activity 处于 pause 状态，比如前台 Activity 打开了一个对话框，这样后面的 Activity 就处于 pause 状态</p>
</li>
<li><p>Service</p>
<p>进程持有一个 Service 这个 Service 和一个可见的 Activity 绑定。</p>
</li>
</ol>
<p>可见进程是非常重要的进程，除非前台进程已经把系统的可用内存耗光，否则系统不会终止可见进程。</p>
<h4 id="4-2-3-服务进程"><a href="#4-2-3-服务进程" class="headerlink" title="4.2.3 服务进程"></a>4.2.3 服务进程</h4><p>服务进程（Service Process）可能在播放音乐或在后台下载文件，除非系统内存不足，否则系统会尽量维持服务进程的运行。</p>
<p>当一个进程满足下面一个条件时，系统会认定它为服务进程。</p>
<ol>
<li><p>Service</p>
<p>如果一个进程中运行着一个 Service，并且这个 service 是通过 startService 开启的，那这个进程就是一个服务进程。</p>
</li>
</ol>
<h4 id="4-2-4-后台进程"><a href="#4-2-4-后台进程" class="headerlink" title="4.2.4 后台进程"></a>4.2.4 后台进程</h4><p>系统会把后台进程（Background Process）保存在一个 LruCache 列表中，因为终止后台进程对用户体验影响不大，所以系统会酌情清理部分后台进程。</p>
<p>你可以在 Activity 的 onSaveInstanceState() 方法中保存一些数据，以免在应用在后台被系统清理掉后，用户已输入的信息被清空，导致要重新输入。</p>
<p>当一个进程满足下面条件时，系统会认定它为后台进程。</p>
<ol>
<li><p>Activity</p>
<p>当进程持有一个用户不可见的 Activity（Activity 的 onStop() 方法被调用），但是 onDestroy 方法没有被调用，这个进程就会被系统认定为后台进程。</p>
</li>
</ol>
<h4 id="4-2-5-空进程"><a href="#4-2-5-空进程" class="headerlink" title="4.2.5 空进程"></a>4.2.5 空进程</h4><p>当一个进程不包含任何活跃的应用组件，则被系统认定为是空进程。</p>
<p>系统保留空进程的目的是为了加快下次启动进程的速度。</p>
<h2 id="5-图片对内存有什么影响？"><a href="#5-图片对内存有什么影响？" class="headerlink" title="5. 图片对内存有什么影响？"></a>5. 图片对内存有什么影响？</h2><p>大部分 App 都免不了使用大量的图片，比如电商应用和外卖应用等。</p>
<p>图片在 Android 中对应的是 Bitmap 和 Drawable 类，我们从网络上加载下来的图片最终会转化为 Bitmap。</p>
<p>图片会消耗大量内存，如果使用图片不当，很容易就会造成 OOM。</p>
<p>下面我们来看下 Bitmap 与内存有关的一些内容。</p>
<h3 id="5-1-获取-Bitmap-占用的内存大小"><a href="#5-1-获取-Bitmap-占用的内存大小" class="headerlink" title="5.1 获取 Bitmap 占用的内存大小"></a>5.1 获取 Bitmap 占用的内存大小</h3><ol>
<li><p>Bitmap.getByteCount()</p>
<p>Bitmap 提供了一个 getByteCount() 方法获取图片占用的内存大小，但是这个方法只能在程序运行时动态计算。</p>
</li>
<li><p>图片内存公式</p>
<p>图片占用内存公式：宽 * 高 * 一个像素占用的内存。</p>
<p>假如我们现在有一张 2048 * 2048 的图片，并且编码格式为 ARGB_8888，那么这个图片的大小为 2048 * 2048 * 4 = 16, 777, 216 个字节，也就是 16M。</p>
<p>如果厂商给虚拟机设置的堆大小是 256M，那么像这样的图片，应用最极限的情况只能使用 16 张。</p>
<p>我们的应用在运行时，不仅仅是我们自己写的代码需要消耗内存，还有库中创建的对象同样需要占用堆内存，也就是别说 16 张，多来几张应用就挂了。</p>
</li>
</ol>
<h3 id="5-2-Bitmap-像素大小"><a href="#5-2-Bitmap-像素大小" class="headerlink" title="5.2 Bitmap 像素大小"></a>5.2 Bitmap 像素大小</h3><p>一张图片中每一个像素的大小取决于它的解码选项，而 Android 中能够选择的 Bitmap 解码选项有四种。</p>
<p>下面四种解码选项中的的 ARGB 分别代表透明度和三原色 Alpha、Red、Green、Blue。</p>
<ol>
<li><p>ARGB_8888</p>
<p>ARGB 四个通道的值都是 8 位，加起来 32 位，也就是每个像素占 4 个字节</p>
</li>
<li><p>ARGB_4444</p>
<p>ARGB 四个通道的值都是 4 位，加起来 16 位，也就是每个像素占 2 个字节</p>
</li>
<li><p>RGB_565</p>
<p>RGB 三个通道分别是 5 位、6 位、5 位，加起来 16 位，也就是每个像素占 2 个字节</p>
</li>
<li><p>ALPHA_8</p>
<p>只有 A 通道，占 8 位，也就是每个像素占 1 个字节</p>
</li>
</ol>
<h3 id="5-3-Glide"><a href="#5-3-Glide" class="headerlink" title="5.3 Glide"></a>5.3 Glide</h3><p>如果服务器返回给我们的图片是 200 * 200，但是我们的 ImageView 大小是 100 * 100，如果直接把图片加载到 ImageView 中，那就是一种内存浪费。</p>
<p>但是使用的 Glide 的话，那这个问题就不用担心了，因为 Glide 会根据 ImageView 的大小把图片大小调整成 ImageView 的大小加载图片，并且 Glide 有三级缓存，在内存缓存中，Glide 会根据屏幕大小选择合适的大小作为图片内存缓存区的大小。</p>
<h2 id="6-什么是内存泄漏？"><a href="#6-什么是内存泄漏？" class="headerlink" title="6. 什么是内存泄漏？"></a>6. 什么是内存泄漏？</h2><h3 id="6-1-内存泄漏简介"><a href="#6-1-内存泄漏简介" class="headerlink" title="6.1 内存泄漏简介"></a>6.1 内存泄漏简介</h3><p>内存泄漏指的是，当一块内存没有被使用，但无法被 GC 时的情况。</p>
<p>堆中一块泄漏的内存就像是地上一块扫不掉的口香糖，都很让人讨厌。</p>
<p>一个典型的例子就是匿名内部类持有外部类的引用，外部类应该被销毁时，GC 却无法回收它，比如在 Activity 中创建 Handler 就有可能出现这种情况。</p>
<p>内存泄漏的表现就是可用内存逐渐减少，比如下图中是一种比较严重的内存泄漏现象，无法被回收的内存逐渐累积，直到无更多可用内存可申请时，就会导致 OOM。</p>
<p>![内存泄漏.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="528"/>)</p>
<h3 id="6-2-常见的内存泄漏原因"><a href="#6-2-常见的内存泄漏原因" class="headerlink" title="6.2 常见的内存泄漏原因"></a>6.2 常见的内存泄漏原因</h3><p>常见的造成内存泄漏的原因有如下几个。</p>
<h4 id="6-2-1-非静态内部类"><a href="#6-2-1-非静态内部类" class="headerlink" title="6.2.1 非静态内部类"></a>6.2.1 非静态内部类</h4><ol>
<li><p>原因</p>
<p>非静态内部类会持有外部类的实例，比如匿名内部类。</p>
<p>匿名内部类指的是一个没有人类可识别名称的类，但是在字节码中，它还是会有构造函数的，而它的构造函数中会包含外部类的实例。</p>
<p>比如在 Activity 中以匿名内部类的方式声明 Handler 或 AsyncTask，当 Activity 关闭时，由于 Handler 持有 Activity 的强引用，导致 GC 无法对 Activity 进行回收。</p>
<p>当我们通过 Handler 发送消息时，消息会加入到 MessageQueue 队列中交给 Looper 处理，当有消息还没发送完毕时，Looper 会一直运行，在这个过程中会一直持有 Handler，而 Handler 又持有外部类 Activity 的实例，这就导致了 Activity 无法被释放。</p>
</li>
<li><p>解决</p>
<p>我们可以把 Handler 或 AsyncTask 声明为静态内部类，并且使用 WeakReference 包住 Activity，这样 Handler 拿到的就是一个 Activity 的弱引用，GC 就可以回收 Activity。</p>
<p>这种方式适用于所有匿名内部类导致的内存泄漏问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static class MyHandler extends Handler &#123;</span><br><span class="line">    Activity activity;</span><br><span class="line">    </span><br><span class="line">    public MyHandler(Activity activity) &#123;</span><br><span class="line">        activity = new WeakReference&lt;&gt;(activity).get();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message message) &#123;</span><br><span class="line">       // ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-2-2-静态变量"><a href="#6-2-2-静态变量" class="headerlink" title="6.2.2 静态变量"></a>6.2.2 静态变量</h4><ol>
<li><p>原因</p>
<p>静态变量导致内存泄漏的原因是因为长生命周期对象持有了短生命周期对象的引用，导致短生命周期对象无法被释放。</p>
<p>比如一个单例持有了 Activity 的引用，而 Activity 的生命周期可能很短，用户一打开就关闭了，但是单例的生命周期往往是与应用的生命周期相同的。</p>
</li>
<li><p>解决</p>
<p>如果单例需要 Context， 可以考虑使用 ApplicationContext，这样单例持有的 Context 引用就是与应用的生命周期相同的了。</p>
</li>
</ol>
<h4 id="6-2-3-资源未释放"><a href="#6-2-3-资源未释放" class="headerlink" title="6.2.3 资源未释放"></a>6.2.3 资源未释放</h4><ol>
<li>忘了注销 BroadcastReceiver</li>
<li>打开了数据库游标（Cursor）忘了关闭</li>
<li>打开流忘了关闭</li>
<li>创建了 Bitmap 但是调用 recycle 方法回收 Bitmap 使用的内存</li>
<li>使用 RxJava 忘了在 Activity 退出时取消任务</li>
<li>使用协程忘了在 Activity 退出时取消任务</li>
</ol>
<h4 id="6-2-4-Webview"><a href="#6-2-4-Webview" class="headerlink" title="6.2.4 Webview"></a>6.2.4 Webview</h4><ol>
<li><p>原因</p>
<p>不同的 Android 版本的 Webview 会有差异，加上不同厂商定制 ROM 的 Webview 的差异，导致 Webview 存在很大的兼容问题。</p>
<p>一般情况下，在应用中只要使用一次 Webview，它占用的内存就不会被释放。</p>
</li>
<li><p>解决</p>
<p><a href="https://juejin.im/post/WebView内存泄漏--解决方法小结" target="_blank" rel="noopener">WebView内存泄漏–解决方法小结</a></p>
</li>
</ol>
<h2 id="7-什么是内存抖动？"><a href="#7-什么是内存抖动？" class="headerlink" title="7. 什么是内存抖动？"></a>7. 什么是内存抖动？</h2><h3 id="7-1-内存抖动简介"><a href="#7-1-内存抖动简介" class="headerlink" title="7.1 内存抖动简介"></a>7.1 内存抖动简介</h3><p>当我们在短时间内频繁创建大量临时对象时，就会引起内存抖动，比如在一个 for 循环中创建临时对象实例。</p>
<p>下面这张图就是内存抖动时的一个内存图表现，它的形状是锯齿形的，而中间的垃圾桶代表着一次 GC。</p>
<p>这个是 Memory Profiler 提供的内存实时图，后面会对 Memory Profiler 进行一个更详细的介绍。</p>
<p>![image](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="430"/>)</p>
<h3 id="7-2-预防内存抖动的方法"><a href="#7-2-预防内存抖动的方法" class="headerlink" title="7.2 预防内存抖动的方法"></a>7.2 预防内存抖动的方法</h3><ul>
<li>尽量避免在循环体中创建对象</li>
<li>尽量不要在自定义 View 的 onDraw() 方法中创建对象，因为这个方法会被频繁调用</li>
<li>对于能够复用的对象，可以考虑使用对象池把它们缓存起来</li>
</ul>
<h2 id="8-什么是-Memory-Profiler？"><a href="#8-什么是-Memory-Profiler？" class="headerlink" title="8. 什么是 Memory Profiler？"></a>8. 什么是 Memory Profiler？</h2><h3 id="8-1-Profiler"><a href="#8-1-Profiler" class="headerlink" title="8.1 Profiler"></a>8.1 Profiler</h3><h4 id="8-1-1-Profiler-简介"><a href="#8-1-1-Profiler-简介" class="headerlink" title="8.1.1 Profiler 简介"></a>8.1.1 Profiler 简介</h4><p>Profiler 是 Android Studio 为我们提供的性能分析工具，它包含了 CPU、内存、网络以及电量的分析信息，而 Memory Profiler 则是 Profiler 中的其中一个版块。</p>
<p>打开 Profiler 有下面三种方式。</p>
<ol>
<li>View &gt; Tool Windows &gt; Android Profiler</li>
<li>下方的 Profiler 标签</li>
<li>双击 shift 搜索 profiler</li>
</ol>
<p>打开 Profiler 后，可以看到下面这样的面板，而在左边的 SESSIONS 面板的右上角，有一个加号，在这里可以选择我们想要进行分析的应用。</p>
<p>![Profiler](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="370"/>)</p>
<h4 id="8-1-2-Profiler-高级选项"><a href="#8-1-2-Profiler-高级选项" class="headerlink" title="8.1.2 Profiler 高级选项"></a>8.1.2 Profiler 高级选项</h4><p>开了高级选项后，我们在 Memory Profiler 中就能看到用一个白色垃圾桶表示的 GC 动作。</p>
<p>打开 Profiler 的方式：Run &gt; Edit Configucation &gt; Profiling &gt; Enable advanced profiling</p>
<h3 id="8-2-Memory-Profiler-简介"><a href="#8-2-Memory-Profiler-简介" class="headerlink" title="8.2 Memory Profiler 简介"></a>8.2 Memory Profiler 简介</h3><p>Memory Profiler 是 Profiler 的其中一个功能，点击 Profiler 中蓝色的 Memory 面板，我们就进入了 Memory Profiler 界面。</p>
<h3 id="8-3-堆转储"><a href="#8-3-堆转储" class="headerlink" title="8.3 堆转储"></a>8.3 堆转储</h3><p>在堆转储（Dump Java Heap）面板中有 Instance View（实例视图）面板，Instance View 面板的下方有 References 和 Bitmap Preview 两个面板，通过 Bitmap Preview，我们能查看该 Bitmap 对应的图片是哪一张，通过这种方式，很容易就能找到图片导致的内存问题。</p>
<p>要注意的是，Bitmap Preview 功能只有在 7.1 及以下版本的设备中才能使用。</p>
<p>![堆转储.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="761"/>)</p>
<h3 id="8-4-查看内存分配详情"><a href="#8-4-查看内存分配详情" class="headerlink" title="8.4 查看内存分配详情"></a>8.4 查看内存分配详情</h3><p>在 7.1 及以下版本的设备中，可以通过 Record 按钮记录一段时间内的内存分配情况。</p>
<p>而在 8.0 及以上版本的设别中，可以通过拖动时间线来查看一段时间内的内存分配情况。</p>
<p>点击 Record 按钮后，Profiler 会为我们记录一段时间内的内存分配情况。在内存分配面板中，我们可以查看对象的分配的位置，比如下面的 Bitmap 就是在 onCreate 方法的 22 行创建的。</p>
<p>![查看内存分配.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="647"/>)</p>
<h2 id="9-什么是-MAT？"><a href="#9-什么是-MAT？" class="headerlink" title="9. 什么是 MAT？"></a>9. 什么是 MAT？</h2><h3 id="9-1-MAT-介绍"><a href="#9-1-MAT-介绍" class="headerlink" title="9.1 MAT 介绍"></a>9.1 MAT 介绍</h3><p>对于内存泄漏问题，Memory Profiler 只能给我们提供一个简单的分析，不能够帮我们确认具体发生问题的地方。</p>
<p>而 MAT 就可以帮我们做到这一点，MAT 的全称是 Memory Analyzer Tool，它是一款功能强大的 Java 堆内存分析工具，可以用于查找内存泄漏以及查看内存消耗情况。</p>
<h3 id="9-2-MAT-使用步骤"><a href="#9-2-MAT-使用步骤" class="headerlink" title="9.2 MAT 使用步骤"></a>9.2 MAT 使用步骤</h3><p>要想通过 MAT 分析内存泄漏，我们做下面几件事情。</p>
<ol>
<li><p>到 MAT 的官网<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">下载 MAT</a>。</p>
</li>
<li><p>使用 Memory Profiler 的堆转储功能，导出 hprof（Heap Profile）文件。</p>
</li>
<li><p>配置 platform-tools 环境变量</p>
</li>
<li><p>使用命令将 Memory Profiler 中导出来的 hprof 文件转换为 MAT 可以解析的 hprof 文件，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">platform-tools hprof-conv ../原始文件.hprof ../输出文件.hprof</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开 MAT</p>
</li>
<li><p>File &gt; open Heap dump ，选择我们转换后的文件</p>
</li>
</ol>
<h3 id="9-3-注意事项"><a href="#9-3-注意事项" class="headerlink" title="9.3 注意事项"></a>9.3 注意事项</h3><ol>
<li><p>如果在 mac 上打不开 MAT，可以参考<a href="https://www.jianshu.com/p/9bbbe3c4cc8b" target="_blank" rel="noopener">Eclipse Memory Analyzer在Mac启动报错</a></p>
</li>
<li><p>如果在 mac 上配置 platform-tools 不成功的话，可以直接定位到 Android SDK 下的 platform-tools 目录，直接使用 hprof-conv 工具，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> hprof-conv -z ../原始文件.hprof ../输出文件.hprof</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="10-怎么用-MAT-分析内存泄漏？"><a href="#10-怎么用-MAT-分析内存泄漏？" class="headerlink" title="10. 怎么用 MAT 分析内存泄漏？"></a>10. 怎么用 MAT 分析内存泄漏？</h2><p>我在项目中定义了一个静态的回调列表 sCallbacks，并且把 MemoryLeakActivity 添加到了这个列表中，然后反复进出这个 Activity，我们可以看到这个 Activity 的实例有 8 个，这就属于内存泄漏现象，下面我们来看下怎么找出这个内存泄漏。</p>
<p>首先，按 9.2 小节的步骤打开我们的堆转储文件，打开后，我们可以看到 MAT 为我们分析的一个预览页。</p>
<p>![MAT 预览页.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1122" height="930"/>)</p>
<p>打开左上角的直方图，我们可以看到一个类列表，输入我们想搜索的类，就可以看到它的实例数。</p>
<p>![MAT 直方图.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="714" height="503"/>)</p>
<p>我们右键 MemoryLeakActivity 类，选择 List Objects &gt; with incoming references 查看这个 Activity 的实例。</p>
<p>点击后，我们能看到一个实例列表，再右键其中一个实例，选择 Path to GC Roots &gt; with all references 查看该实例被谁引用了，导致无法回收。</p>
<p>![MAT 实例列表.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="714" height="503"/>)</p>
<p>选择 with all references 后，我们可以看到该实例被静态对象 sCallbacks 持有，导致无法被释放。</p>
<p>![MAT 查看引用](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="901" height="435"/>)</p>
<p>这样就完成了一次简单的内存泄漏的分析。</p>
<h2 id="11-什么是-LeakCanary？"><a href="#11-什么是-LeakCanary？" class="headerlink" title="11. 什么是 LeakCanary？"></a>11. 什么是 LeakCanary？</h2><h3 id="11-1-LeakCanary-简介"><a href="#11-1-LeakCanary-简介" class="headerlink" title="11.1 LeakCanary 简介"></a>11.1 LeakCanary 简介</h3><p>如果使用 MAT 来分析内存问题，会有一些难度，而且效率也不是很高。</p>
<p>为了能迅速发现内存泄漏，Square 公司基于 MAT 开源了 <a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a>。</p>
<p>LeakCanary 是一个内存泄漏检测框架。</p>
<h3 id="11-2-LeakCanary-原理"><a href="#11-2-LeakCanary-原理" class="headerlink" title="11.2 LeakCanary 原理"></a>11.2 LeakCanary 原理</h3><ol>
<li><p>检测保留的实例</p>
<p>LeakCanary 是基于 LeakSentry 开发的，LeakSentry 会 hook Android 生命周期，自动检测当 Activity 或 Fragment 被销毁时，它们的实例是否被回收了。</p>
<p>销毁的实例会传给 RefWatcher，RefWatcher 会持有它们的弱引用。</p>
<p>你也可以观察所有不再需要的实例，比如一个不再使用的 View，不再使用的 Presenter 等。</p>
<p>如果等待了 5 秒，并且 GC 触发了之后，弱引用还没有被清理，那么 RefWatcher 观察的实例就可能处于内存泄漏状态了。</p>
</li>
<li><p>堆转储</p>
<p>当保留实例（Retained Instance）的数量达到了一个阈值，LeakCanary 会进行堆转储，并把数据放进 hprof 文件中。</p>
<p>当 App 可见时，这个阈值是 5 个保留实例，当 App 不可见时，这个阈值是 1 个保留实例。</p>
</li>
<li><p>泄漏踪迹</p>
<p>LeakCanary 会解析 hprof 文件，并且找出导致 GC 无法回收实例的引用链，这也就是泄漏踪迹（Leak Trace）。</p>
<p>泄漏踪迹也叫最短强引用路径，这个路径是 GC Roots 到实例的路径。</p>
</li>
<li><p>泄漏分组</p>
<p>当有两个泄漏分析结果相同时，LeakCanary 会根据子引用链来判断它们是否是同一个原因导致的，如果是的话，LeakCanary 会把它们归为同一组，以免重复显示同样的泄漏信息。</p>
</li>
</ol>
<h3 id="11-2-安装-LeakCanary"><a href="#11-2-安装-LeakCanary" class="headerlink" title="11.2 安装 LeakCanary"></a>11.2 安装 LeakCanary</h3><h4 id="11-2-1-AndroidX-项目"><a href="#11-2-1-AndroidX-项目" class="headerlink" title="11.2.1 AndroidX 项目"></a>11.2.1 AndroidX 项目</h4><ol>
<li><p>添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 使用 debugImplementation 是因为 LeakCanary 一般不用于发布版本</span><br><span class="line">  debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:2.0-alpha-3&apos;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>监控特定对象</p>
<p>LeakCanary 默认只监控 Activity 实例是否泄漏，如果我们想监控其他的对象是否也泄漏，就要使用 RefWatcher。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在 Application 中定义一个 RefWatcher 的静态变量</span><br><span class="line">companion object &#123;</span><br><span class="line">    val refWatcher = LeakSentry.refWatcher</span><br><span class="line">&#125;	</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 2. 使用 RefWatcher 监控该对象</span><br><span class="line">MyApplication.refWatcher.watch(object);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置监控选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private fun initLeakCanary() &#123;</span><br><span class="line">    LeakSentry.config = LeakSentry.config.copy(watchActivities = false)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="11-2-1-非-AndroidX-项目"><a href="#11-2-1-非-AndroidX-项目" class="headerlink" title="11.2.1 非 AndroidX 项目"></a>11.2.1 非 AndroidX 项目</h4><ol>
<li><p>添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.6.3&apos;</span><br><span class="line">  releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.6.3&apos;</span><br><span class="line">  // 只有在你使用了 support library fragments 的时候才需要下面这一项</span><br><span class="line">  debugImplementation &apos;com.squareup.leakcanary:leakcanary-support-fragment:1.6.3&apos;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 LeakCanary</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">  @Override public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    // 不需要在 LeakCanary 用来做堆分析的进程中初始化 LeakCanary</span><br><span class="line">    if (!LeakCanary.isInAnalyzerProcess(this)) &#123;</span><br><span class="line">      LeakCanary.install(this);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>监控特定对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1. 在 Application 中定义一个获取 RefWatcher 的静态方法</span><br><span class="line">public static RefWatcher getRefWatcher() &#123;</span><br><span class="line">    return LeakCanary.installedRefWatcher();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 2. 使用 RefWatcher 监控该对象</span><br><span class="line">MyApplication.getRefWatcher().watch(object);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置监控选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">    private void installLeakCanary() &#123;</span><br><span class="line">        RefWatcher refWatcher = LeakCanary.refWatcher(this)</span><br><span class="line">          .watchActivities(false)</span><br><span class="line">          .buildAndInstall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>当安装完成，并且重新安装了应用后，我们可以在桌面看到 LeakCanary 用于分析内存泄漏的应用。</p>
<p>下面这两张图中，第一个是 LeakCanary 为非 AndroidX 项目安装的应用，第二个是 LeakCanary 为 AndroidX 项目安装的应用。</p>
<p>![内存泄漏进程.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="447" height="529"/>)</p>
<h3 id="11-4-使用-LeakCanary-分析内存泄漏"><a href="#11-4-使用-LeakCanary-分析内存泄漏" class="headerlink" title="11.4 使用 LeakCanary 分析内存泄漏"></a>11.4 使用 LeakCanary 分析内存泄漏</h3><p>下面是一个静态变量持有 Activity 导致 Activity 无法被释放的一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   public class MemoryLeakActivity extends AppCompatActivity &#123;</span><br><span class="line">   </span><br><span class="line">       public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">       @Override</span><br><span class="line">       protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">           super.onCreate(savedInstanceState);</span><br><span class="line">           activities.add(this);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们可以在 Logcat 中看到泄漏实例的引用链。</p>
<p>![Locat 内存泄漏信息](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="973" height="886"/>)</p>
<p>除了 Logcat，我们还可以在 Leaks App 中看到引用链。</p>
<p>点击桌面上 LeakCanary 为我们安装的 Leaks 应用后，可以看到 activities 变量，之所以在这里会显示这个变量，是因为 LeakCanary 分析的结果是这个变量持有了某个实例，导致该实例无法被回收。</p>
<p>![Leaks1.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="660" height="368"/>)</p>
<p>点击这一项泄漏信息，我们可以看到一个泄漏信息概览页。</p>
<p>![Leaks2](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="590" height="1280"/>)</p>
<p>我们点击第一项 MemoryActivity Leaked，可以看到泄漏引用链的详情。</p>
<p>![Leaks3.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1093" height="1280"/>)</p>
<p>通过上面这些步骤，很简单地就能找到 LeakCanary 为我们分析的导致内存泄漏的地方。</p>
<h2 id="12-怎么获取和监听系统内存状态？"><a href="#12-怎么获取和监听系统内存状态？" class="headerlink" title="12. 怎么获取和监听系统内存状态？"></a>12. 怎么获取和监听系统内存状态？</h2><p>Android 提供了两种方式让我们可以监听系统内存状态，下面我们就来看看这两种方式的用法。</p>
<h3 id="12-1-ComponentCallback2"><a href="#12-1-ComponentCallback2" class="headerlink" title="12.1 ComponentCallback2"></a>12.1 ComponentCallback2</h3><p>在 Android 4.0 后，Android 应用可以通过在 Activity 中实现 ComponentCallback2 接口获取系统内存的相关事件，这样就能在系统内存不足时提前知道这件事，提前做出释放内存的操作，避免我们自己的应用被系统干掉。</p>
<p>ComponentCallnback2 提供了 onTrimMemory(level) 回调方法，在这个方法里我们可以针对不同的事件做出不同的释放内存操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">   import android.content.ComponentCallbacks2</span><br><span class="line">   </span><br><span class="line">   class MainActivity : AppCompatActivity(), ComponentCallbacks2 &#123;</span><br><span class="line">   </span><br><span class="line">       /**</span><br><span class="line">        * 当应用处于后台或系统资源紧张时，我们可以在这里方法中释放资源，</span><br><span class="line">        * 避免被系统将我们的应用进行回收</span><br><span class="line">        * @param level 内存相关事件</span><br><span class="line">        */</span><br><span class="line">       override fun onTrimMemory(level: Int) &#123;</span><br><span class="line">   </span><br><span class="line">           // 根据不同的应用生命周期和系统事件进行不同的操作</span><br><span class="line">           when (level) &#123;</span><br><span class="line">   </span><br><span class="line">               // 应用界面处于后台</span><br><span class="line">               ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN -&gt; &#123;</span><br><span class="line">                   // 可以在这里释放 UI 对象</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               // 应用正常运行中，不会被杀掉，但是系统内存已经有点低了</span><br><span class="line">               ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE,</span><br><span class="line">             </span><br><span class="line">               // 应用正常运行中，不会被杀掉，但是系统内存已经非常低了，</span><br><span class="line">               // 这时候应该释放一些不必要的资源以提升系统性能</span><br><span class="line">               ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW,</span><br><span class="line">             </span><br><span class="line">               // 应用正常运行，但是系统内存非常紧张，</span><br><span class="line">               // 系统已经开始根据 LRU 缓存杀掉了大部分缓存的进程</span><br><span class="line">               // 这时候我们要释放所有不必要的资源，不然系统可能会继续杀掉所有缓存中的进程</span><br><span class="line">               ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL -&gt; &#123;</span><br><span class="line">                   // 释放资源</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               // 系统内存很低，系统准备开始根据 LRU 缓存清理进程，</span><br><span class="line">               // 这时我们的程序在 LRU 缓存列表的最近位置，不太可能被清理掉，</span><br><span class="line">               // 但是也要去释放一些比较容易恢复的资源，让系统内存变得充足</span><br><span class="line">               ComponentCallbacks2.TRIM_MEMORY_BACKGROUND,</span><br><span class="line">             </span><br><span class="line">               // 系统内存很低，并且我们的应用处于 LRU 列表的中间位置，</span><br><span class="line">               // 这时候如果还不释放一些不必要资源，那么我们的应用可能会被系统干掉</span><br><span class="line">               ComponentCallbacks2.TRIM_MEMORY_MODERATE,</span><br><span class="line">             </span><br><span class="line">               // 系统内存非常低，并且我们的应用处于 LRU 列表的最边缘位置，</span><br><span class="line">               // 系统会有限考虑干掉我们的应用，如果想活下来，就要把所有能释放的资源都释放了</span><br><span class="line">               ComponentCallbacks2.TRIM_MEMORY_COMPLETE -&gt; &#123;</span><br><span class="line">                   /*</span><br><span class="line">                    * 把所有能释放的资源都释放了</span><br><span class="line">                   */</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               // 应用从系统接收到一个无法识别的内存等级值，</span><br><span class="line">               // 跟一般的低内存消息提醒一样对待这个事件</span><br><span class="line">               </span><br><span class="line">               else -&gt; &#123;</span><br><span class="line">                   // 释放所有不重要的数据结构。</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="12-2-ActivityManager-getMemoryInfo"><a href="#12-2-ActivityManager-getMemoryInfo" class="headerlink" title="12.2 ActivityManager.getMemoryInfo()"></a>12.2 ActivityManager.getMemoryInfo()</h3><p>Android 提供了一个 ActivityManager.getMemoryInfo() 方法给我们查询内存信息，这个方法会返回一个 ActivityManager.MemoryInfo 对象，这个对象包含了系统当前内存状态，这些状态信息包括可用内存、总内存以及低杀内存阈值。</p>
<p>MemoryInfo 中包含了一个 lowMemory 布尔值，这个布尔值用于表明系统是否处于低内存状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   fun doSomethingMemoryIntensive() &#123;</span><br><span class="line">       // 在做一些需要很多内存的任务前，</span><br><span class="line">       // 检查设备是否处于低内存状态、</span><br><span class="line">       if (!getAvailableMemory().lowMemory) &#123;</span><br><span class="line">           // 做需要很多内存的任务</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 获取 MemoryInfo 对象</span><br><span class="line">   private fun getAvailableMemory(): ActivityManager.MemoryInfo &#123;</span><br><span class="line">       val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager</span><br><span class="line">       return ActivityManager.MemoryInfo().also &#123; memoryInfo -&gt;</span><br><span class="line">           activityManager.getMemoryInfo(memoryInfo)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="13-还有哪些内存优化技巧？"><a href="#13-还有哪些内存优化技巧？" class="headerlink" title="13. 还有哪些内存优化技巧？"></a>13. 还有哪些内存优化技巧？</h2><h3 id="13-1-谨慎使用-Service"><a href="#13-1-谨慎使用-Service" class="headerlink" title="13.1 谨慎使用 Service"></a>13.1 谨慎使用 Service</h3><p>让一个没用的 Service 在后台运行对于一个应用的内存管理来说是一件最糟糕的事情。</p>
<p>要在 Service 的任务完成后停止它，不然 Service 占用的这块内存会泄漏。</p>
<p>当你的应用中运行着一个 Service，除非系统内存不足，否则它不会被干掉。</p>
<p>这就导致对于系统来说 Service 的运行成本很高，因为 Service 占用的内存其他的进程是不能使用的。</p>
<p>Android 有一个缓存进程列表，当可用内存减少时，这个列表也会随之缩小，这就会导致应用间的切换变得很慢。</p>
<p>如果我们是用 Service 监听一些系统广播，可以考虑使用 JobScheduler。</p>
<p>如果你真的要用 Service，可以考虑使用 IntentService，IntentService 是 Service 的一个子类，在它的内部有一个工作线程来处理耗时任务，当任务执行完后，IntentService 就会自动停止。</p>
<h3 id="13-2-选择优化后的数据容器"><a href="#13-2-选择优化后的数据容器" class="headerlink" title="13.2 选择优化后的数据容器"></a>13.2 选择优化后的数据容器</h3><p>Java 提供的部分数据容器并不适合 Android，比如 HashMap，HashMap 需要中存储每一个键值对都需要一个额外的 Entry 对象。</p>
<p>Android 提供了几个优化后的数据容器，包括 SparseArray、SparseBooleanArray 以及 LongSparseArray。</p>
<p>SparseArray 之所以更高效，是因为它的设计是只能使用整型作为 key，这样就避免了自动装箱的开销。</p>
<h3 id="13-3-小心代码抽象"><a href="#13-3-小心代码抽象" class="headerlink" title="13.3 小心代码抽象"></a>13.3 小心代码抽象</h3><p>抽象可以优化代码的灵活性和可维护性，但是抽象也会带来其他成本。</p>
<p>抽象会导致更多的代码需要被执行，也就是需要更多的时间和把更多的代码映射到内存中。</p>
<p>如果某段抽象代码带来的好处不大，比如一个地方可以直接实现而不需要用到接口的，那就不用接口。</p>
<h3 id="13-4-使用-protobuf-作为序列化数据"><a href="#13-4-使用-protobuf-作为序列化数据" class="headerlink" title="13.4 使用 protobuf 作为序列化数据"></a>13.4 使用 protobuf 作为序列化数据</h3><p>Protocol buffers 是 Google 设计的，它可以对结构化的数据序列化，与 XML 类似，不过比 XML 更小，更快，而且更简单。</p>
<p>如果你决定使用 protobuf 作为序列化数据格式，那在客户端代码中应该使用轻量级的 protobuf。</p>
<p>因为一般的 protobuf 会生成冗长的代码，这样会导致内存增加、APK 大小增加，执行速度变慢等问题。</p>
<p>更多关于 protobuf 的信息可以查看 <a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.md#installation-lite-version-with-maven" target="_blank" rel="noopener">protobuf readme</a> 中的 “轻量级版本” 。</p>
<h3 id="13-5-Apk-瘦身"><a href="#13-5-Apk-瘦身" class="headerlink" title="13.5 Apk 瘦身"></a>13.5 Apk 瘦身</h3><p>有些资源和第三方库会在我们不知情的情况下大量消耗内存。</p>
<p>Bitmap 大小、资源、动画以及第三方库会影响到 APK 的大小，Android Studio 提供了 R8 和 ProGuard 帮助我们缩小 Apk，去掉不必要的资源。</p>
<p>如果你使用的 Android Studio 版本是 3.3 以下的，可以使用 ProGuard，3.3 及以上版本的可以使用 R8。</p>
<h3 id="13-6-使用-Dagger2-进行依赖注入"><a href="#13-6-使用-Dagger2-进行依赖注入" class="headerlink" title="13.6 使用 Dagger2 进行依赖注入"></a>13.6 使用 Dagger2 进行依赖注入</h3><p>依赖注入框架不仅可以简化我们的代码，而且能让我们在测试代码的时候更方便。</p>
<p>如果我们想在应用中使用依赖注入，可以考虑使用 Dagger2。</p>
<p>Dagger2 是在编译期生成代码，而不是用反射实现的，这样就避免了反射带来的内存开销，而是在编译期生成代码，</p>
<h3 id="13-7-谨慎使用第三方库"><a href="#13-7-谨慎使用第三方库" class="headerlink" title="13.7 谨慎使用第三方库"></a>13.7 谨慎使用第三方库</h3><p>当你决定使用一个不是为移动平台设计的第三方库时，你需要对它进行优化，让它能更好地在移动设备上运行。</p>
<p>这些第三方库包括日志、分析、图片加载、缓存以及其他框架，都有可能带来性能问题。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h3 id="1-视频"><a href="#1-视频" class="headerlink" title="1. 视频"></a>1. 视频</h3><ol>
<li><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">Top团队大牛带你玩转Android性能分析与优化</a></li>
</ol>
<h3 id="2-书籍"><a href="#2-书籍" class="headerlink" title="2. 书籍"></a>2. 书籍</h3><ol>
<li><a href="https://book.douban.com/subject/27021800/" target="_blank" rel="noopener">《Android 移动性能实战》</a></li>
<li><a href="https://book.douban.com/subject/30358046/" target="_blank" rel="noopener">《Android 进阶解密》</a></li>
<li><a href="https://book.douban.com/subject/30160468/" target="_blank" rel="noopener">《深入解析Android虚拟机》</a></li>
</ol>
<h3 id="3-文章"><a href="#3-文章" class="headerlink" title="3. 文章"></a>3. 文章</h3><ol>
<li>国内<ol>
<li><a href="https://www.jianshu.com/p/b5a8a1d09712" target="_blank" rel="noopener">Android Low memory killer</a></li>
<li><a href="https://www.jianshu.com/p/a20ff3a3c3b5" target="_blank" rel="noopener">Android onTrimMemory</a></li>
<li><a href="https://www.jianshu.com/p/80b2068a90a8" target="_blank" rel="noopener">关于 Android 中 Bitmap 的 ARGB_8888、ALPHA_8、ARGB_4444、RGB_565 的理解</a></li>
<li><a href="https://blog.csdn.net/cqupt_chen/article/details/11068129" target="_blank" rel="noopener">android dalvik heap 浅析</a></li>
<li><a href="https://www.jianshu.com/p/3233c33f6a79" target="_blank" rel="noopener">Android内存分配/回收的一个问题-为什么内存使用很少的时候也GC</a></li>
<li><a href="https://www.jianshu.com/p/5a32226d2ce0" target="_blank" rel="noopener">IntentService和Service区别</a></li>
</ol>
</li>
<li>国外<ol>
<li><a href="https://developer.android.com/studio/profile/android-profiler" target="_blank" rel="noopener">利用 Android Profiler 测量应用性能</a></li>
<li><a href="https://developer.android.google.cn/topic/performance/memory.html" target="_blank" rel="noopener">Manage Your App’s Memory</a></li>
<li><a href="https://developer.android.com/studio/profile/memory-profiler.html" target="_blank" rel="noopener">使用 Memory Profiler 查看 Java 堆和内存分配</a></li>
<li><a href="https://developer.android.com/training/articles/perf-tips" target="_blank" rel="noopener">Performance tips</a></li>
<li><a href="https://square.github.io/leakcanary/" target="_blank" rel="noopener">LeakCanary 官网</a></li>
<li><a href="https://developer.android.com/guide/components/processes-and-threads" target="_blank" rel="noopener">进程和线程</a></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/28/探索 Android 启动优化方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/28/探索 Android 启动优化方法/" class="post-title-link" itemprop="url">探索 Android 启动优化方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 23:22:20" itemprop="dateCreated datePublished" datetime="2019-12-28T23:22:20+08:00">2019-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:26:17" itemprop="dateModified" datetime="2019-12-31T14:26:17+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="探索-Android-启动优化方法"><a href="#探索-Android-启动优化方法" class="headerlink" title="探索 Android 启动优化方法"></a>探索 Android 启动优化方法</h1><p><a href="https://juejin.im/post/5d5aa36af265da03963b9913" target="_blank" rel="noopener">来源</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca87e72e9460ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="首图"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16caa0e6ea0ca7a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="目录.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1-启动优化的意义"><a href="#1-启动优化的意义" class="headerlink" title="1. 启动优化的意义"></a>1. 启动优化的意义</h3><p>假如我们去到一家餐厅，叫了半天都没有人过来点菜，那等不了多久就没耐心想走了。</p>
<p>对于 App 也是一样的，如果我们打开一个应用半天都打不开，那很快的我们也会失去耐心。</p>
<p>启动速度是用户对我们应用的第一体验，用户只有启动我们的应用才能使用我们应用中的功能。</p>
<p>就算我们应用内部设计得再精美，其他性能优化地再好，如果打开速度很慢的话，用户对我们应用的第一印象还是很差。</p>
<p>你可以追求完美，要做到应用在 1 毫秒内启动。</p>
<p>但是一般情况下， 我们只要做到超越竞品或者远超竞品，就能在启动速度这一个点上让用户满意。</p>
<p>用户选择 App 的时候会考虑各种因素，而我们 App 开发者能做的就是在争取通过各种技术让我们的 App 从众多竞品中脱颖而出。</p>
<h3 id="2-文章内容"><a href="#2-文章内容" class="headerlink" title="2. 文章内容"></a>2. 文章内容</h3><p>这篇文章分为三部分。</p>
<ul>
<li><p>第一部分：启动优化基础</p>
<p>第一部分是第 1 大节，讲的是应用启动流程的相关知识。</p>
</li>
<li><p>第二部分：启动优化方法</p>
<p>第二部分是第 2~4 大节，讲的是常用的优化启动速度的工具和方法。</p>
</li>
<li><p>第三部分：优化方法改进</p>
<p>第三部分是第 5~7 大节，讲的是常规优化启动方法的改进型解决方案。</p>
</li>
</ul>
<h2 id="1-三种启动状态"><a href="#1-三种启动状态" class="headerlink" title="1. 三种启动状态"></a>1. 三种启动状态</h2><p>启动速度对 App 的整体性能非常重要，所以谷歌官方给出了一篇启动速度优化的文章。</p>
<p>在这篇文章中，把启动分为了三种状态：热启动、暖启动和冷启动。</p>
<p>下面我们来看下三种启动状态的特点。</p>
<h3 id="1-1-热启动"><a href="#1-1-热启动" class="headerlink" title="1.1 热启动"></a>1.1 热启动</h3><p>热启动是三种启动状态中是最快的一种，因为热启动是从后台切到了前台，不需要再创建 Applicaiton，也不需要再进行渲染布局等操作。</p>
<h3 id="1-2-暖启动"><a href="#1-2-暖启动" class="headerlink" title="1.2 暖启动"></a>1.2 暖启动</h3><p>暖启动的启动速度介于冷启动和热启动之间，暖启动只会重走 Activity 的生命周期，不会重走进程创建和 Application 的创建和生命周期等。</p>
<h3 id="1-3-冷启动"><a href="#1-3-冷启动" class="headerlink" title="1.3 冷启动"></a>1.3 冷启动</h3><p>冷启动经历了一系列流程，耗时也是最多的，理解冷启动整体流程的理解，可以帮助我们寻找之后的一个优化方向。</p>
<p>冷启动也是优化的衡量标准，一般在线上进行的启动优化都是以冷启动速度为指标的。</p>
<p>启动速度的优化方向是 Application 和 Activity 生命周期阶段，这是我们开发者能控制的时间，其他阶段都是系统做的。</p>
<p>冷启动流程可以分为三步：创建进程、启动应用和绘制界面。</p>
<ol>
<li><p>创建进程</p>
<p>创建进程阶段主要做了下面三件事，这三件事都是系统做的。</p>
<ul>
<li>启动 App</li>
<li>加载空白 Window</li>
<li>创建进程</li>
</ul>
</li>
<li><p>启动应用</p>
<p>启动应用阶段主要做了下面三件事，从这些开始，随后的任务和我们自己写的代码有一定的关系。</p>
<ul>
<li>创建 Application</li>
<li>启动主线程</li>
<li>创建 MainActivity</li>
</ul>
</li>
<li><p>绘制界面</p>
<p>绘制界面阶段主要做了下面三件事。</p>
<ul>
<li>加载布局</li>
<li>布置屏幕</li>
<li>首帧绘制</li>
</ul>
</li>
</ol>
<h2 id="2-两种测量方法"><a href="#2-两种测量方法" class="headerlink" title="2. 两种测量方法"></a>2. 两种测量方法</h2><p>上一节介绍了三种启动状态，这一节我们来看一下常用的两种测量启动时间的方法：命令测量和埋点测量。</p>
<h3 id="2-1-命令测量"><a href="#2-1-命令测量" class="headerlink" title="2.1 命令测量"></a>2.1 命令测量</h3><p>命令测量指的是用 adb 命令测量启动时间，通过下面两步就能实现 adb 命令测量应用启动时间</p>
<ol>
<li>输入测量命令</li>
<li>分析测量结果</li>
</ol>
<h4 id="2-2-1-输入测量命令"><a href="#2-2-1-输入测量命令" class="headerlink" title="2.2.1 输入测量命令"></a>2.2.1 输入测量命令</h4><p>我们在终端中输入一条 adb 命令打开我们要测量的应用，打开后系统会输出应用的启动时间。</p>
<p>下面就是测量启动时间的 adb 命令。</p>
<p>![adb 命令1.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="946" height="362"/>)</p>
<p>首屏 Activity 也要加上包名，比如下面这样的。</p>
<p>![adb 命令2.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1022" height="362"/>)</p>
<h4 id="2-2-2-分析测量结果"><a href="#2-2-2-分析测量结果" class="headerlink" title="2.2.2 分析测量结果"></a>2.2.2 分析测量结果</h4><p>![adb 输出结果.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="684"/>)</p>
<p>上面是命令执行完成后显示的内容，在输出中可以看到三个值：ThisTime、TotalTime 和 WaitTime。</p>
<p>下面我们来看下这三个值分别代表什么。</p>
<ul>
<li><p>ThisTime</p>
<p>ThisTime 代表最后一个 Activity 启动所需要的时间，也就是最后一个 Activity 的启动耗时。</p>
</li>
<li><p>TotalTime</p>
<p>TotalTime 代表所有 Activity 启动耗时，在上面的输出中，TotalTime 和 ThisTime 是一样的，因为这个 Demo 没有写 Splash 界面。</p>
<p>也就是这个 App 打开了 Application 后就直接打开了 MainActivity 界面，没有启动其他页面。</p>
</li>
<li><p>WaitTime</p>
<p>WaitTime 是 AMS 启动 Activity 的总耗时。</p>
</li>
</ul>
<p>这三者之间的关系如下。</p>
<p>ThisTime &lt;= TotalToime &lt; WaitTime</p>
<h3 id="2-2-埋点测量"><a href="#2-2-埋点测量" class="headerlink" title="2.2 埋点测量"></a>2.2 埋点测量</h3><p>埋点测量指的是我们在应用启动阶段埋一个点，在启动结束时再埋一个点，两者之间的差值就是 App 的启动耗时。</p>
<p>通过下面三步可以实现埋点测量。</p>
<ol>
<li>定义埋点工具类</li>
<li>记录启动时间</li>
<li>计算启动耗时</li>
</ol>
<h4 id="2-2-1-定义埋点工具类"><a href="#2-2-1-定义埋点工具类" class="headerlink" title="2.2.1 定义埋点工具类"></a>2.2.1 定义埋点工具类</h4><p>使用埋点测量的第一步是定义一个记录埋点工具类。</p>
<p>在这里要注意的是，除了 System.currentTimeMillis() 以外，我们还可以用 SystemClock.currentThreadTimeMillis() 记录时间。</p>
<p>通过 SystemClock 拿到的是 CPU 真正执行的时间，这个时间与下一大节要讲的 Systrace 上记录的时间点是一样的。</p>
<p>![LaunchTimer.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1020" height="924"/>)</p>
<h4 id="2-2-2-记录启动时间"><a href="#2-2-2-记录启动时间" class="headerlink" title="2.2.2 记录启动时间"></a>2.2.2 记录启动时间</h4><p>使用埋点测量的第二步是记录启动时间。</p>
<p>开始记录的位置放在 Application 的 attachBaseContext 方法中，attachBaseContext 是我们应用能接收到的最早的一个生命周期回调方法。</p>
<p>![记录启动时间.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1124" height="644"/>)</p>
<h4 id="2-2-3-计算启动耗时"><a href="#2-2-3-计算启动耗时" class="headerlink" title="2.2.3 计算启动耗时"></a>2.2.3 计算启动耗时</h4><p>计算启动耗时的一个误区就是在 onWindowFocusChanged 方法中计算启动耗时。</p>
<p>onWindowFocusChanged 方法只是 Activity 的首帧时间，是 Activity 首次进行绘制的时间，首帧时间和界面完整展示出来还有一段时间差，不能真正代表界面已经展现出来了。</p>
<p>按首帧时间计算启动耗时并不准确，我们要的是用户真正看到我们界面的时间。</p>
<p>正确的计算启动耗时的时机是要等真实的数据展示出来，比如在列表第一项的展示时再计算启动耗时。</p>
<p>在 Adapter 中记录启动耗时要加一个布尔值变量进行判断，避免 onBindViewHolder 方法被多次调用导致不必要的计算。</p>
<p>![计算启动耗时.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="1205"/>)</p>
<h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><h3 id="2-3-1-命令测量优缺点"><a href="#2-3-1-命令测量优缺点" class="headerlink" title="2.3.1 命令测量优缺点"></a>2.3.1 命令测量优缺点</h3><ul>
<li><p>命令测量优点</p>
<ul>
<li><p>线下使用方便</p>
<p>adb 命令测量启动速度的方式在线下使用比较方便，而且这种方式还能用于测量竞品。</p>
</li>
</ul>
</li>
<li><p>命令测量缺点</p>
<ul>
<li><p>不能带到线上</p>
<p>如果一条 adb 命令带到线上去，没有 app 也没有系统帮我们执行这一条 adb 命令，我们就拿不到这些数据，所以不能带到线上。</p>
</li>
<li><p>不严谨和精确</p>
<p>不能精确控制启动时间的开始和结束。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-2-埋点测量的特点"><a href="#2-3-2-埋点测量的特点" class="headerlink" title="2.3.2 埋点测量的特点"></a>2.3.2 埋点测量的特点</h4><ul>
<li><p>精确</p>
<p>手动打点的方式比较精确，因为我们可以精确控制开始和结束的位置。</p>
</li>
<li><p>可带到线上</p>
<p>使用埋点测量进行用户数据的采集，可以很方便地带到线上，把数据上报给服务器。</p>
<p>服务器可以针对所有用户上报的启动数据，每天做一个整合，计算出一个平均值，然后对比不同版本的启动速度。</p>
</li>
</ul>
<h2 id="3-两个分析工具"><a href="#3-两个分析工具" class="headerlink" title="3. 两个分析工具"></a>3. 两个分析工具</h2><p>常用的分析方法耗时的工具有 Systrace 和 Traceview，它们两个是相互补充的关系，我们要在不同的场景下使用不同的工具，这样才能发挥工具的最大作用。</p>
<p>本节内容如下。</p>
<ul>
<li>Traceview</li>
<li>Systrace</li>
<li>小结</li>
</ul>
<h3 id="3-1-Traceview"><a href="#3-1-Traceview" class="headerlink" title="3.1 Traceview"></a>3.1 Traceview</h3><p>Traceview 能以图形的形式展示代码的执行时间和调用栈信息，而且 Traceview 提供的信息非常全面，因为它包含了所有线程。</p>
<p>Traceview 的使用可以分为两步：开始跟踪、分析结果。</p>
<p>下面我们来看看这两步的具体操作。</p>
<h4 id="3-1-1-开始跟踪"><a href="#3-1-1-开始跟踪" class="headerlink" title="3.1.1 开始跟踪"></a>3.1.1 开始跟踪</h4><p>我们可以通过 Debug.startMethodTracing(“输出文件”) 就可以开始跟踪方法，记录一段时间内的 CPU 使用情况。</p>
<p>当我们调用了 Debug.stopMethodTracing() 停止跟踪方法后，系统就会为我们生成一个文件，我们可以通过 Traceview 查看这个文件记录的内容。</p>
<p>文件生成的位置在 Android/data/包名/files 下，下面我们来看一个示例。</p>
<p>我们在 Application 的 onCreate 方法的开头开始追踪方法，然后在结尾结束追踪，在这里只是对 BlockCanary 卡顿监测框架进行初始化。</p>
<p>![startMethodTracing.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="679"/>)</p>
<p>startMethodTracing 方法真正调用的其实是另一个重载方法，在这个重载方法可以传入 bufferSize。</p>
<p>bufferSize 就是分析结果文件的大小，默认是 8 兆。</p>
<p>我们可以进行扩充，比如扩充为 16 兆、32 兆等。</p>
<p>这个重载方法的第三个参数是标志位，这个标志位只有一个选项，就是 TRACE_COUNT_ALLOCS。</p>
<p>![startMethodTracing2.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1144" height="608"/>)</p>
<h4 id="3-1-2-分析结果"><a href="#3-1-2-分析结果" class="headerlink" title="3.1.2 分析结果"></a>3.1.2 分析结果</h4><p>运行了程序后，有两种方式可以获取到跟踪结果文件。</p>
<p>第一种方式是通过下面的命令把文件拉到项目根目录。</p>
<p>![pull 跟踪结果.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1086" height="364"/>)</p>
<p>第二种方式是在 AS 右下方的文件资源管理器中定位到 /sdcard/android/data/包名/files/ 目录下，然后自己找个地方保存。</p>
<p>![文件资源管理器.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="482" height="784"/>)</p>
<p>我们在 AS 中打开跟踪文件 mytrace.trace 后，就可以用 Profiler 查看跟踪的分析结果。</p>
<p>![查看跟踪文件.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="662"/>)</p>
<p>在分析结果上比较重要的是 5 种信息。</p>
<ul>
<li><p>代码指定的时间范围</p>
<p>这个时间范围是我们通过 Debug 类精确指定的</p>
</li>
<li><p>选中的时间范围</p>
<p>我们可以拖动时间线，选择查看一段时间内某条线程的调用堆栈</p>
</li>
<li><p>进程中存在的线程</p>
<p>在这里可以看到在指定时间范围内进程中只有主线程和 BlockCanary 的线程，一共有 4 条线程。</p>
</li>
<li><p>调用堆栈</p>
<p>在上面的跟踪信息中，我选中了 main，也就是主线程。</p>
<p>还把时间范围缩小到了特定时间区域内，放大了这个时间范围内主线程的调用堆栈信息</p>
</li>
<li><p>方法耗时</p>
<p>当我们把鼠标放到某一个方法上的时候，我们可以看到这个方法的耗时，比如上面的 initBlockCanary 的耗时是 19 毫秒。</p>
</li>
</ul>
<h3 id="3-2-Systrace"><a href="#3-2-Systrace" class="headerlink" title="3.2 Systrace"></a>3.2 Systrace</h3><p>Systrace 结合了 Android 内核数据，分析了线程活动后会给我们生成一个非常精确 HTML 格式的报告。</p>
<p>Systrace 提供的 Trace 工具类默认只能 API 18 以上的项目中才能使用，如果我们的兼容版本低于 API 18，我们可以使用 TraceCompat。</p>
<p>Systrace 的使用步骤和 Traceview 差不多，分为下面两步。</p>
<ul>
<li>调用跟踪方法</li>
<li>查看跟踪结果</li>
</ul>
<h4 id="3-2-2-调用跟踪方法"><a href="#3-2-2-调用跟踪方法" class="headerlink" title="3.2.2 调用跟踪方法"></a>3.2.2 调用跟踪方法</h4><p>首先在 Application 中调用 Systrace 的跟踪方法。</p>
<p>![beginSection.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1086" height="644"/>)</p>
<p>然后连接设备，在终端中定位到 Android SDK 目录下，比如我的 Android SDK 目录在 /users/oushaoze/library/Android/sdk 。</p>
<p>这时候我打开 SDK 目录下的 platform-tools/systrace 就能看到 systrace.py 的一个 python 文件。</p>
<p>Systrace 是一个 Python 脚本，输入下面命令，运行 systrace ，开始追踪系统信息。</p>
<p>![systrace命令.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1066" height="434"/>)</p>
<p>这行命令附加了下面一些选项。</p>
<ul>
<li><p>-t …</p>
<p>-t 后面表示的是跟踪的时间，比如上面设定的是 10 秒就结束。</p>
</li>
<li><p>-o …</p>
<p>-o 后面表示把文件输出到指定目录下。</p>
</li>
<li><p>-a …</p>
<p>-a 后面表示的是要启动的应用包名</p>
</li>
</ul>
<p>输入完这行命令后，可以看到开始跟踪的提示。看到 Starting tracing 后可以打开打开我们的应用。</p>
<p>10 秒后，会看到 Wrote trace HTML file: ….。</p>
<p>![systrace输出.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1066" height="504"/>)</p>
<p>上面这段输出就是说追踪完毕，追踪到的信息都写到 trace.html 文件中了，接下来我们打开这个文件。</p>
<h4 id="3-2-3-查看跟踪结果"><a href="#3-2-3-查看跟踪结果" class="headerlink" title="3.2.3 查看跟踪结果"></a>3.2.3 查看跟踪结果</h4><p>![Systrace.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="550"/>)</p>
<p>打开文件后我们可以看到上面这样的一个视图，在这里有几个需要特别关注的地方。</p>
<ul>
<li><p>8 核</p>
<p>我运行 Systrace 的设备是 8 核的，所以这里的 Kernel 下面是 8 个 CPU。</p>
</li>
<li><p>缩放</p>
<p>当我们选中缩放后，缩放的方式是上下移动，不是左右移动。</p>
</li>
<li><p>移动</p>
<p>选择移动后，我们可以拖动我们往下查看其它进程的分析信息。</p>
</li>
<li><p>时间片使用情况</p>
<p>时间片使用情况指的是各个 CPU 在特定时间内的时间片使用情况，当我们用缩放把特定时间段内的时间片信息放大，我们就可以看到时间片是被哪个线程占用了。</p>
</li>
<li><p>运行中的进程</p>
<p>左侧一栏除了各个内核外，还会显示运行中的进程。</p>
</li>
</ul>
<p>我们往下移动，可以看到 MyAppplication 进程的线程活动情况。</p>
<p>![Systrace_myapp.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="549"/>)</p>
<p>在这个视图上我们主要关注三个点。</p>
<ul>
<li><p>主线程</p>
<p>在这里我们主要关注主线程的运行了哪些方法</p>
</li>
<li><p>跟踪的时间段</p>
<p>刚才在代码中设置的标签是 AppOnCreate，在这里就显示了这个跟踪时间段的标签</p>
</li>
<li><p>耗时</p>
<p>我们选中 AppOnCreate 标签后，就可以看到这个方法的耗时。</p>
<p>在 Slice 标签下的耗时信息包括 Wall Duration 和 CPU Duration，下面是它们的区别。</p>
<ul>
<li><p>Wall Duration</p>
<p>Wall Time 是执行这段代码耗费的时间，不能作为优化指标。</p>
<p>假如我们的代码要进入锁的临界区，如果锁被其他线程持有，当前线程就进入了阻塞状态，而等待的时间是会被计算到 Wall Time 中的。</p>
</li>
<li><p>CPU Duration</p>
<p>CPU Duration 是 CPU 真正花在这段代码上的时间，是我们关心的优化指标。</p>
<p>在上面的例子中 Wall Duration 是 84 毫秒，CPU Duration 是 34 毫秒，也就是在这段时间内一共有 50 毫秒 CPU 是处于休息状态的，真正执行代码的时间只花了 34 毫秒。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><h4 id="3-3-1-Traceview-的两个特点"><a href="#3-3-1-Traceview-的两个特点" class="headerlink" title="3.3.1 Traceview 的两个特点"></a>3.3.1 Traceview 的两个特点</h4><p>Traceview 有两个特点：可埋点、开销大。</p>
<ul>
<li><p>可埋点</p>
<p>Traceview 的好处之一是可以在代码中埋点，埋点后可以用 CPU Profiler 进行分析。</p>
<p>因为我们现在优化的是启动阶段的代码，如果我们打开 App 后直接通过 CPU Profiler 进行记录的话，就要求你有单身三十年的手速，点击开始记录的时间要和应用的启动时间完全一致。</p>
<p>有了 Traceview，哪怕你是老年人手速也可以记录启动过程涉及的调用栈信息。</p>
</li>
<li><p>开销大</p>
<p>Traceview 的运行时开销非常大，它会导致我们程序的运行变慢。</p>
<p>之所以会变慢，是因为它会通过虚拟机的 Profiler 抓取我们当前所有线程的所有调用堆栈。</p>
<p>因为这个问题，Traceview 也可能会带偏我们的优化方向。</p>
<p>比如我们有一个方法，这个方法在正常情况下的耗时不大，但是加上了 Traceview 之后可能会发现它的耗时变成了原来的十倍甚至更多。</p>
</li>
</ul>
<h4 id="3-3-2-Systrace-的两个特点"><a href="#3-3-2-Systrace-的两个特点" class="headerlink" title="3.3.2 Systrace 的两个特点"></a>3.3.2 Systrace 的两个特点</h4><p>Systrace 的两个特点：开销小、直观。</p>
<ul>
<li><p>开销小</p>
<p>Systrace 开销非常小，不像 Traceview，因为它只会在我们埋点区间进行记录。</p>
<p>而 Traceview 是会把所有的线程的堆栈调用情况都记录下来。</p>
</li>
<li><p>直观</p>
<p>在 Systrace 中我们可以很直观地看到 CPU 利用率的情况。</p>
<p>当我们发现 CPU 利用率低的时候，我们可以考虑让更多代码以异步的方式执行，以提高 CPU 利用率。</p>
</li>
</ul>
<h4 id="3-3-3-Traceview-与-Systrace-的两个区别"><a href="#3-3-3-Traceview-与-Systrace-的两个区别" class="headerlink" title="3.3.3 Traceview 与 Systrace 的两个区别"></a>3.3.3 Traceview 与 Systrace 的两个区别</h4><ul>
<li><p>查看工具</p>
<p>Traceview 分析结果要使用 Profiler 查看。</p>
<p>Systrace 分析结果是在浏览器查看 HTML 文件。</p>
</li>
<li><p>埋点工具类</p>
<p>Traceview 使用的是 Debug.startMethodTracing()。</p>
<p>Systrace 用的是 Trace.beginSection() 和 TraceCompat.beginSection()。</p>
</li>
</ul>
<h2 id="4-两种优化方法"><a href="#4-两种优化方法" class="headerlink" title="4. 两种优化方法"></a>4. 两种优化方法</h2><p>常用的两种优化方法有两种，这两种是可以结合使用的。</p>
<p>第一种是闪屏页，在视觉上让用户感觉启动速度快，第二种是异步初始化。</p>
<h3 id="4-1-闪屏页"><a href="#4-1-闪屏页" class="headerlink" title="4.1 闪屏页"></a>4.1 闪屏页</h3><p>闪屏页是优化启动速度的一个小技巧，虽然对实际的启动速度没有任何帮助，但是能让用户感觉比启动的速度要快一些。</p>
<p>闪屏页就是在 App 打开首屏 Activity 前，首先显示一张图片，这张图片可以是 Logo 页，等 Activity 展示出来后，再把 Theme 变回来。</p>
<p>冷启动的其中一步是创建一个空白 Window，闪屏页就是利用这个空白 Window 显示占位图。</p>
<p>通过下面四个步骤可以实现闪屏页。</p>
<ol>
<li>定义闪屏图</li>
<li>定义闪屏主题</li>
<li>设置主题</li>
<li>换回主题</li>
</ol>
<h4 id="4-1-1-定义闪屏图"><a href="#4-1-1-定义闪屏图" class="headerlink" title="4.1.1 定义闪屏图"></a>4.1.1 定义闪屏图</h4><p>第一步是在 drawable 目录下创建一个 splash.xml 文件。</p>
<p>![splash.xml.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1066" height="644"/>)</p>
<h4 id="4-1-2-定义闪屏主题"><a href="#4-1-2-定义闪屏主题" class="headerlink" title="4.1.2 定义闪屏主题"></a>4.1.2 定义闪屏主题</h4><p>第二步是在 values/styles.xml 中定义一个 Splash 主题。</p>
<p>![SplashTheme.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1066" height="854"/>)</p>
<h4 id="4-1-3-设置主题"><a href="#4-1-3-设置主题" class="headerlink" title="4.1.3 设置主题"></a>4.1.3 设置主题</h4><p>第三步是在清单文件中设置 Theme。</p>
<p>![ActivityTheme.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1066" height="644"/>)</p>
<h4 id="4-1-4-换回主题"><a href="#4-1-4-换回主题" class="headerlink" title="4.1.4 换回主题"></a>4.1.4 换回主题</h4><p>第四步是在调用 super.onCreate 方法前切换回来</p>
<p>![换回主题.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"/>)</p>
<h3 id="4-2-异步初始化"><a href="#4-2-异步初始化" class="headerlink" title="4.2 异步初始化"></a>4.2 异步初始化</h3><p>我们这一节来看一下怎么用线程池进行异步初始化。</p>
<p>本节内容包括如下部分，</p>
<ul>
<li>异步初始化简介</li>
<li>线程池大小</li>
<li>线程池基本用法</li>
</ul>
<h4 id="4-2-1-异步初始化简介"><a href="#4-2-1-异步初始化简介" class="headerlink" title="4.2.1 异步初始化简介"></a>4.2.1 异步初始化简介</h4><p>异步优化就是把初始化的工作分细分成几个子任务，然后让子线程分别执行这些子任务，加快初始化过程。</p>
<p>如果你对怎么在 Android 中实现多线程不了解，可以看一下我的上一篇文章：探索 Android 多线程优化，在这篇文章中我对在 Android 使用多线程的方法做了一个简单的介绍。</p>
<p>有些初始化代码在子线程执行的时候可能会出现问题，比如要求在 onCreate 结束前执行完成。</p>
<p>这种情况我们可以考虑使用 CountDownLatch 实现，实在不行的时候就保留这段初始化代码在主线程中执行。</p>
<h4 id="4-2-2-线程池大小"><a href="#4-2-2-线程池大小" class="headerlink" title="4.2.2 线程池大小"></a>4.2.2 线程池大小</h4><p>我们可以使用线程池来实现异步初始化，使用线程池需要注意的是线程池大小的设置。</p>
<p>线程池大小要根据不同的设备设置不同的大小，有的手机是四核的，有的是八核的，如果把线程池大小设为固定数值的话是不合理的。</p>
<p>我们可以参考 AsyncTask 中设置的线程池大小，在 AsyncTask 中有 CPU_COUNT 和 CORE_POOL_SIZE。</p>
<ul>
<li><p>CPU_COUNT</p>
<p>CPU_COUNT 的值是设备的 CPU 核数。</p>
</li>
<li><p>CORE_POOL_SIZE</p>
<p>CORE_POOL_SIZE 是线程池核心大小，这个值的最小值是 2，最大值是 Math.min(CPU_COUNT - 1, 4)。</p>
<p>当设备的核数为 8 时，CORE_POOL_SIZE 的值为 4，当设备核数为 4 时，这个值是 3，也就是 CORE_POOL_SIZE 的最大值是 4。</p>
</li>
</ul>
<h4 id="4-2-3-线程池基本用法"><a href="#4-2-3-线程池基本用法" class="headerlink" title="4.2.3 线程池基本用法"></a>4.2.3 线程池基本用法</h4><p>在这里我们可以参考 AsyncTask 的做法来设置线程池的大小，并把初始化的工作提交到线程池中。</p>
<p>![线程池.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1054" height="1168"/>)</p>
<h2 id="6-改进优化方案"><a href="#6-改进优化方案" class="headerlink" title="6. 改进优化方案"></a>6. 改进优化方案</h2><p>上一节介绍了怎么通过线程池处理初始化任务，这一节我们看一下改进的异步初始化工具：启动器（LaunchStarter）。</p>
<p>这一节的内容包括如下部分。</p>
<ul>
<li>线程池实现的不足</li>
<li>启动器简介</li>
<li>启动器工作流程</li>
<li>实现任务等待执行</li>
<li>实现任务依赖关系</li>
</ul>
<h3 id="6-1-线程池实现的不足"><a href="#6-1-线程池实现的不足" class="headerlink" title="6.1 线程池实现的不足"></a>6.1 线程池实现的不足</h3><p>通过线程池处理初始化任务的方式存在三个问题。</p>
<ul>
<li><p>代码不够优雅</p>
<p>假如我们有 100 个初始化任务，那像上面这样的代码就要写 100 遍，提交 100 次任务。</p>
</li>
<li><p>无法限制在 onCreate 中完成</p>
<p>有的第三方库的初始化任务需要在 Application 的 onCreate 方法中执行完成，虽然可以用 CountDownLatch 实现等待，但是还是有点繁琐。</p>
</li>
<li><p>无法实现存在依赖关系</p>
<p>有的初始化任务之间存在依赖关系，比如极光推送需要设备 ID，而 initDeviceId() 这个方法也是一个初始化任务。</p>
</li>
</ul>
<h3 id="6-2-启动器简介"><a href="#6-2-启动器简介" class="headerlink" title="6.2 启动器简介"></a>6.2 启动器简介</h3><p>启动器的核心思想是充分利用多核 CPU ，自动梳理任务顺序。</p>
<p>第一步是我们要对代码进行任务化，任务化是一个简称，比如把启动逻辑抽象成一个任务。</p>
<p>第二步是根据所有任务的依赖关系排序生成一个有向无环图，这个图是自动生成的，也就是对所有任务进行排序。</p>
<p>比如我们有个任务 A 和任务 B，任务 B 执行前需要任务 A 执行完，这样才能拿到特定的数据，比如上面提到的 initDeviceId。</p>
<p>第三步是多线程根据排序后的优先级依次执行，比如我们现在有三个任务 A、B、C。</p>
<p>假如任务 B 依赖于任务 A，这时候生成的有向无环图就是 ACB，A 和 C 可以提前执行，B 一定要排在 A 之后执行。</p>
<h3 id="6-3-启动器工作流程"><a href="#6-3-启动器工作流程" class="headerlink" title="6.3 启动器工作流程"></a>6.3 启动器工作流程</h3><p>![启动器流程图.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="577"/>)</p>
<ul>
<li><p>Head Task</p>
<p>Head Task 就是所有任务执行前要做的事情，在这里初始化一些其他任务依赖的资源，也可以只是打个 Log。</p>
</li>
<li><p>Tail Task</p>
<p>Tail Task 可用于执行所有任务结束后打印一个 Log，或者是上报数据等任务。</p>
</li>
<li><p>Idle Task</p>
<p>Idle Task 是在程序空闲时执行的任务。</p>
</li>
</ul>
<p>如果我们不使用异步的方案，所有的任务都会在主线程执行。</p>
<p>为了让其他线程分担主线程的工作，我们可以把初始化的工作拆分成一个个的子任务，采用并发的方式，使用多个线程同时执行这些子任务。</p>
<h3 id="6-4-实现任务等待执行"><a href="#6-4-实现任务等待执行" class="headerlink" title="6.4 实现任务等待执行"></a>6.4 实现任务等待执行</h3><p>启动器（LaunchStarter）使用了有向无环图实现任务之间的依赖关系，具体的代码可以在本文最下方找到。</p>
<p>使用启动器需要完成 3 个步骤。</p>
<ul>
<li>添加依赖</li>
<li>定义任务</li>
<li>开始任务</li>
</ul>
<p>下面我们来看下这 3 个步骤的具体操作。</p>
<h4 id="6-4-1-添加依赖"><a href="#6-4-1-添加依赖" class="headerlink" title="6.4.1 添加依赖"></a>6.4.1 添加依赖</h4><p>首先在项目根目录的 build.gradle 中添加 jitpack 仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    // ...</span><br><span class="line">    maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后在 app 模块的 build.gradle 中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 启动器</span><br><span class="line">  implementation &apos;com.github.zeshaoaaa:LaunchStarter:0.0.1&apos;</span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="6-4-2-定义任务"><a href="#6-4-2-定义任务" class="headerlink" title="6.4.2 定义任务"></a>6.4.2 定义任务</h4><p>定义任务这个步骤涉及了几个概念：MainTask、Task、needWait 和 run。</p>
<ul>
<li><p>MainTask</p>
<p>MainTask 是需要在主线程执行的任务</p>
</li>
<li><p>Task</p>
<p>Task 就是在工作线程执行的任务。</p>
</li>
<li><p>needWait</p>
<p>InitWeexTask 中重写了 needWait 方法，这个方法返回 true 表示 onCreate 的执行需要等待这个任务完成。</p>
</li>
<li><p>run</p>
<p>run() 方法中的代码就是需要做的初始化工作</p>
</li>
</ul>
<p>![InitWeexTask.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1160" height="784"/>)</p>
<h4 id="6-4-3-开始任务"><a href="#6-4-3-开始任务" class="headerlink" title="6.4.3 开始任务"></a>6.4.3 开始任务</h4><p>定义好了任务后，我们就可以开始任务了。</p>
<p>这里需要注意的是，如果我们的任务中有需要等待完成的任务，我们可以调用 TaskDispatcher 的 await() 方法等待这个任务完成，比如 InitWeexTask。</p>
<p>使用 await() 方法要注意的是这个方法要在 start() 方法调用后才能使用。</p>
<p>![startDispatcher.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1160" height="678"/>)</p>
<h3 id="6-5-实现任务依赖关系"><a href="#6-5-实现任务依赖关系" class="headerlink" title="6.5 实现任务依赖关系"></a>6.5 实现任务依赖关系</h3><p>除了上面提到的等待功能以外，启动器还支持任务之间存在依赖关系，下面我们来看一个极光推送初始化任务的例子。</p>
<p>在这一节会讲实现任务依赖关系的两个步骤。</p>
<ul>
<li>定义任务</li>
<li>开始任务</li>
</ul>
<h4 id="6-5-1-定义任务"><a href="#6-5-1-定义任务" class="headerlink" title="6.5.1 定义任务"></a>6.5.1 定义任务</h4><p>在这里我们定义两个存在依赖关系的任务：GetDeviceIdTask 和 InitJPush Task。</p>
<p>首先定义 GetDeviceIdTask ，这个任务负责初始化设备 ID 。</p>
<p>![GetDeviceIdTask.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="766"/>)</p>
<p>然后定义InitJPushTask，这个任务负责初始化极光推送 SDK，InitJPushTask 在启动器中是尾部任务 Tail Task。</p>
<p>InitJPushTask 依赖于 GetDeviceIdTask，所以需要重写 dependsOn 方法，在 dependsOn 方法中创建一个 Class 列表，把想依赖的任务的 Class 添加到列表中并返回。</p>
<p>![InitJPushTask.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="911"/>)</p>
<h4 id="6-5-2-开始任务"><a href="#6-5-2-开始任务" class="headerlink" title="6.5.2 开始任务"></a>6.5.2 开始任务</h4><p>GetDeviceIdTask 和 InitJPushTask 这两个任务都不需要等待 Application 的 onCreate 方法执行完成，所以我们这里不需要调用 TaskDispatcher 的 await 方法。</p>
<p>![startTask.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="734"/>)</p>
<h4 id="6-5-3-小结"><a href="#6-5-3-小结" class="headerlink" title="6.5.3 小结"></a>6.5.3 小结</h4><p>上面这两个步骤就能实现通过启动器实现任务之间的依赖关系。</p>
<h2 id="7-延迟执行任务"><a href="#7-延迟执行任务" class="headerlink" title="7. 延迟执行任务"></a>7. 延迟执行任务</h2><p>在我们应用的 Application 和 Activity 中可能存在部分优先级不高的初始化任务，我们可以考虑把这些任务进行延迟初始化，比如放在列表的第一项显示出来后再进行初始化。</p>
<p>常规的延迟初始化方法有两种：onPreDraw 和 postDelayed。</p>
<p>除了常规方法外，还有一种改进的延迟初始化方案：延迟启动器。</p>
<p>本节包括如下内容。</p>
<ul>
<li><p>onPreDraw</p>
<p>onPreDraw 指的是在列表第一项显示后，在 onPreDraw 回调中执行初始化任务</p>
</li>
<li><p>postDelayed</p>
<p>通过 Handler 的 postDelayed 方法延迟执行初始化任务</p>
</li>
<li><p>延迟启动器</p>
</li>
</ul>
<h3 id="7-1-onPreDraw"><a href="#7-1-onPreDraw" class="headerlink" title="7.1 onPreDraw"></a>7.1 onPreDraw</h3><p>这一节我们来看下怎么通过 OnPreDrawListener 把任务延迟到列表显示后再执行。</p>
<p>下面是 onPreDraw 方式实现延迟初始化的 3 个步骤。</p>
<ul>
<li>声明回调接口</li>
<li>调用接口方法</li>
<li>在 Activity 中监听</li>
<li>小结</li>
</ul>
<h4 id="7-1-1-声明回调接口"><a href="#7-1-1-声明回调接口" class="headerlink" title="7.1.1 声明回调接口"></a>7.1.1 声明回调接口</h4><p>第一步先声明一个 OnFeedShowCallback。</p>
<p>![OnFeedShowCallback.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="994" height="504"/>)</p>
<h4 id="7-1-2-调用接口方法"><a href="#7-1-2-调用接口方法" class="headerlink" title="7.1.2 调用接口方法"></a>7.1.2 调用接口方法</h4><p>第二步是在 Adapter 中的第一条显示的时候调用 onFeedShow() 方法。</p>
<p>![AdapterOnFeedShow.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="1126"/>)</p>
<h4 id="7-1-3-在-Activity-中监听"><a href="#7-1-3-在-Activity-中监听" class="headerlink" title="7.1.3 在 Activity 中监听"></a>7.1.3 在 Activity 中监听</h4><p>第三步是在 Activity 中调用 setOnFeedCallback 方法。</p>
<p>![ActivityOnFeedShow.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1214" height="678"/>)</p>
<h4 id="7-1-4-小结"><a href="#7-1-4-小结" class="headerlink" title="7.1.4 小结"></a>7.1.4 小结</h4><p>直接在 onFeedShow 中执行初始化任务的弊端是有可能导致滑动卡顿。</p>
<p>如果我们 onPreDraw 的方式延迟执行初始化任务，假如这个任务耗时是 2 秒，那就意味着在列表显示第一条后的 2 秒内，列表是无法滑动的，用户体验很差。</p>
<h3 id="7-2-postDelayed"><a href="#7-2-postDelayed" class="headerlink" title="7.2 postDelayed"></a>7.2 postDelayed</h3><p>还有一种方式就是通过 Handler.postDelayed 方法发送一个延迟消息，比如延迟到 100 毫秒后执行。</p>
<p>假如在 Activity 中有 1 个 100 行的初始化方法，我们把前 10 行代码放在 postDelayed 中延迟 100 毫秒执行，把前 20 行代码放在 postDelayed 中延迟 200 毫秒执行。</p>
<p>这种实现的确缓解了卡顿的情况，但是这种实现存在两个问题</p>
<ul>
<li><p>不够优雅</p>
<p>假如按上面的例子，可以分出 10 个初始化任务，每一个都放在 不同的 postDelayed 中执行，这样写出来的代码不够优雅。</p>
</li>
<li><p>依旧卡顿</p>
<p>假如把任务延迟 200 毫秒后执行，而 200 后用户还在滑动列表，那还是会发生卡顿。</p>
</li>
</ul>
<h3 id="7-3-延迟启动器"><a href="#7-3-延迟启动器" class="headerlink" title="7.3 延迟启动器"></a>7.3 延迟启动器</h3><h4 id="7-3-1-延迟启动器基本用法"><a href="#7-3-1-延迟启动器基本用法" class="headerlink" title="7.3.1 延迟启动器基本用法"></a>7.3.1 延迟启动器基本用法</h4><p>除了上面说到的方式外，现在我们来说一个更好的解决方案：延迟启动器。</p>
<p>延迟启动器利用了 IdleHandler 实现主线程空闲时才执行任务，IdleHandler 是 Android 提供的一个类，IdleHandler 会在当前消息队列空闲时才执行任务，这样就不会影响用户的操作了。</p>
<p>假如现在 MessageQueue 中有两条消息，在这两条消息处理完成后，MessageQueue 会通知 IdleHandler 现在是空闲状态，然后 IdleHandler 就会开始处理它接收到的任务。</p>
<p>DelayInitDispatcher 配合 onFeedShow 回调来使用效果更好。</p>
<p>下面是一段使用延迟启动器 DelayInitDispatcher 执行初始化任务的示例代码。</p>
<p>![DelayInitDispatcher.png](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1240" height="993"/>)</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>看完了上面提到的一些启动优化技巧，你有没有得到一些启发呢？</p>
<p>又或者是你有没有自己的一些启动优化技巧，不妨在评论区给大家说说。</p>
<p>可能你觉得不值一提的技巧，能解决了其他同学的一个大麻烦。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h3 id="1-视频"><a href="#1-视频" class="headerlink" title="1. 视频"></a>1. 视频</h3><ol>
<li><a href="https://coding.imooc.com/class/308.html" target="_blank" rel="noopener">国内Top团队大牛带你玩转Android性能分析与优化</a></li>
</ol>
<h3 id="2-文章"><a href="#2-文章" class="headerlink" title="2. 文章"></a>2. 文章</h3><ol>
<li><a href="https://developer.android.com/topic/performance/vitals/launch-time" target="_blank" rel="noopener">App startup time</a></li>
<li><a href="https://juejin.im/post/5aec28bb6fb9a07ac90d13dc" target="_blank" rel="noopener">Android App 冷启动优化方案</a></li>
<li><a href="https://developer.android.com/studio/profile/cpu-profiler" target="_blank" rel="noopener">使用 CPU Profiler 检查 CPU Activity 和函数跟踪</a></li>
<li><a href="https://developer.android.com/studio/profile/systrace" target="_blank" rel="noopener">Overview of Systrace</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/12/28/探索 Android 多线程优化方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/28/探索 Android 多线程优化方法/" class="post-title-link" itemprop="url">探索 Android 多线程优化方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-28 22:50:20" itemprop="dateCreated datePublished" datetime="2019-12-28T22:50:20+08:00">2019-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:25:09" itemprop="dateModified" datetime="2019-12-31T14:25:09+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id><a href="#" class="headerlink" title></a></h2><h1 id="探索-Android-多线程优化方法"><a href="#探索-Android-多线程优化方法" class="headerlink" title="探索 Android 多线程优化方法"></a>探索 Android 多线程优化方法</h1><p><a href="https://juejin.im/post/5d45a75de51d4561ee1bdf10" target="_blank" rel="noopener">来源</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p>在我学习 Android 多线程优化方法的过程中，发现我对多线程优化的了解太片面。</p>
<p>写这篇文章的目的是完善我对 Android 多线程优化方法的认识，分享这篇文章的目的是希望大家也能从这些知识从得到一些启发。</p>
<p>这篇文章分为下面三部分。</p>
<ul>
<li><p>第一部分</p>
<p>第一部分讲的是多线程优化的基础知识，包括线程的介绍和线程调度基本原理的介绍。</p>
</li>
<li><p>第二部分</p>
<p>第二部分讲的是多线程优化需要预防的一些问题，包括线程安全问题的介绍和实现线程安全的办法。</p>
</li>
<li><p>第三部分</p>
<p>第三部分讲的是多线程优化可以使用的一些方法，包括线程之间的协作方式与 Android 执行异步任务的常用方式。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/28/探索 Android 多线程优化方法/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/10/11/concurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/concurrentHashMap/" class="post-title-link" itemprop="url">concurrentHashMap</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 20:02:47" itemprop="dateCreated datePublished" datetime="2019-10-11T20:02:47+08:00">2019-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:31:31" itemprop="dateModified" datetime="2019-12-31T14:31:31+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合框架/" itemprop="url" rel="index">
                    <span itemprop="name">集合框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK7的ConcurrentHashMap"><a href="#JDK7的ConcurrentHashMap" class="headerlink" title="JDK7的ConcurrentHashMap"></a>JDK7的ConcurrentHashMap</h3><p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，主要实现原理是实现了<strong>锁分离</strong>的思路解决了多线程的安全问题.</p>
<p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样。</p>
<blockquote>
<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表.</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/11/concurrentHashMap/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiarh</p>
  <div class="site-description" itemprop="description">coding change the world .</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiarh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
