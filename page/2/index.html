<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://jrhlive.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="coding change the world .">
<meta name="keywords" content="jrhlive jrhlife livelife live-life ailife ailive smart-live  stmart-life">
<meta property="og:type" content="website">
<meta property="og:title" content="STAY HUNGRY. STAY FOOLISH.">
<meta property="og:url" content="http://jrhlive.com/page/2/index.html">
<meta property="og:site_name" content="STAY HUNGRY. STAY FOOLISH.">
<meta property="og:description" content="coding change the world .">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STAY HUNGRY. STAY FOOLISH.">
<meta name="twitter:description" content="coding change the world .">

<link rel="canonical" href="http://jrhlive.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>STAY HUNGRY. STAY FOOLISH.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">STAY HUNGRY. STAY FOOLISH.</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Hi,sweet.A new day.</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/10/07/HashMap使用笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/07/HashMap使用笔记/" class="post-title-link" itemprop="url">HashMap使用笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-07 11:15:31" itemprop="dateCreated datePublished" datetime="2019-10-07T11:15:31+08:00">2019-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:31:05" itemprop="dateModified" datetime="2019-12-31T14:31:05+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合框架/" itemprop="url" rel="index">
                    <span itemprop="name">集合框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a href="https://www.jianshu.com/p/32f67f9e71b5" target="_blank" rel="noopener">文稿来源</a></p>
<ol>
<li><p>HashMap<code>其实就是</code>ArrayList<code>和</code>LinkedList<code>的数据结构加上</code>hashCode<code>和</code>equals`方法的思想设计出来的。</p>
</li>
<li><p><code>HashMap</code>是基于<code>Map</code>接口实现的一种键-值对的存储结构，允许<code>null</code>值，同时非有序，非同步(即线程不安全)。</p>
</li>
<li><p><code>HashMap</code>的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/07/HashMap使用笔记/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/10/03/LinkedList使用笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/03/LinkedList使用笔记/" class="post-title-link" itemprop="url">LinkedList使用笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-03 11:12:11" itemprop="dateCreated datePublished" datetime="2019-10-03T11:12:11+08:00">2019-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:33:28" itemprop="dateModified" datetime="2019-12-31T14:33:28+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合框架/" itemprop="url" rel="index">
                    <span itemprop="name">集合框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ol>
<li><p>LinkedList底层是双向链表，同时实现了List接口和Deque接口</p>
</li>
<li><p>可以看作是一个顺序容器，也可以看作是一个队列(Queue)，同时也可以看作是一个栈(Stack)</p>
</li>
<li><p>如果想使用栈或队列等数据结构的话，推荐使用ArrayDeque，它作为栈或队列会比LinkedList有更好的使用性能。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/03/LinkedList使用笔记/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/10/02/ArrayList使用笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/02/ArrayList使用笔记/" class="post-title-link" itemprop="url">ArrayList使用笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-02 11:08:08" itemprop="dateCreated datePublished" datetime="2019-10-02T11:08:08+08:00">2019-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:33:14" itemprop="dateModified" datetime="2019-12-31T14:33:14+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合框架/" itemprop="url" rel="index">
                    <span itemprop="name">集合框架</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h2><ol>
<li><p>Arraylist 就是数组列表</p>
</li>
<li><p>当我们转载的是基本数据int,long,byte,boolean,float,double,char,short的时候，只能存储他们对应的包装类。</p>
</li>
<li><p>底层实现主要是  transient Object[] elementData;</p>
<blockquote>
<p> Java语言的关键字，变量修饰符，如果用<strong>transient</strong>声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用<strong>transient</strong>关键字标记的成员变量不参与序列化过程。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/02/ArrayList使用笔记/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/09/25/深入理解动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/25/深入理解动态代理/" class="post-title-link" itemprop="url">深入理解动态代理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-25 20:50:20" itemprop="dateCreated datePublished" datetime="2019-09-25T20:50:20+08:00">2019-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:32:40" itemprop="dateModified" datetime="2019-12-31T14:32:40+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id><a href="#" class="headerlink" title></a></h2><h1 id="深入理解动态代理"><a href="#深入理解动态代理" class="headerlink" title="深入理解动态代理"></a>深入理解动态代理</h1><p><a href="https://juejin.im/post/5c70094051882562a12aec51" target="_blank" rel="noopener">来源</a></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>最近在阅读retrofit源码时,有个关键的所在就是动态代理，细细回想了一下动态代理,发现之前有些细节还没有理解到位，本篇博文将重新深入理解一下动态代理。</p>
<h1 id="二、关于代理"><a href="#二、关于代理" class="headerlink" title="二、关于代理"></a>二、关于代理</h1><p>中华名族是一个含蓄的名族，讲究微妙和间接的交流方式。对象之间的间接通信也是同样是面向对象设计中一条重要的审美观，迪米特法则也指出“一个对象应该对其他对象保持最少的了解”,间接间通信可以达到“高内聚，低耦合”的效果。<br>代理是一种重要的手段之一，比如生活中的微商代理，厂家委托其代理销售商品，我们只跟微商打交道，不知道背后的“厂家是谁”，微商和厂家就可以抽象为 “代理类”和“委托类”，这样就可以，隐藏委托类的实现、实现客户与委托类之间的解耦，可以不用修改委托类的情况下做一些额外的处理</p>
<h2 id="2-1、代理模式简介"><a href="#2-1、代理模式简介" class="headerlink" title="2.1、代理模式简介"></a>2.1、代理模式简介</h2><p>在《Java与模式》一书中指出”代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的访问”，类图如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d98d4237?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<p>通过类图可以发现，代理模式的代理对象<code>Proxy</code>和目标对象<code>Subject</code>实现同一个接口，客户调用的是<code>Proxy</code>对象，<code>Proxy</code>可以控制<code>Subject</code>的访问，真正的功能实现是在<code>Subject</code>完成的。</p>
<p>适用场景:</p>
<ul>
<li>不希望某些类被直接访问。</li>
<li>访问之前希望先进行一些预处理。</li>
<li>希望对被访问的对象进行内存、权限等方面的控制。</li>
</ul>
<p>优点如下</p>
<ul>
<li>代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。</li>
<li>代理模式主要用于远程代理、虚拟代理和保护代理。其中保护代理可以进行访问权限控制。</li>
</ul>
<h2 id="2-2、静态代理"><a href="#2-2、静态代理" class="headerlink" title="2.2、静态代理"></a>2.2、静态代理</h2><p>“静态”代理，若代理类在程序运行前已经存在，这种通常称为静态代理，比如微商A只代理A品牌的面膜,消费者通过微商才能买到某厂的面膜(控制权)，其中微商和工厂都实现了了Sell的接口</p>
<blockquote>
<p>委托类面膜工厂</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class  FactoryOne :SellMask&#123;</span><br><span class="line">    override fun sell() &#123;</span><br><span class="line">        println(&quot;FactoryOne: 来自工厂A的面膜&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>微商静态代理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class BusinessAgent : SellMask &#123;</span><br><span class="line">    private lateinit var sellMask: SellMask</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        sellMask = FactoryOne()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun sell() &#123;</span><br><span class="line">        println(&quot;BusinessAgent: 微商代理开始在朋友圈打广告&quot;)</span><br><span class="line">        sellMask.sell()</span><br><span class="line">        print(&quot;BusinessAgent: 赚了一大把&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>共同接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SellMask &#123;</span><br><span class="line">    fun sell()</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="2-3、相似模式的比较"><a href="#2-3、相似模式的比较" class="headerlink" title="2.3、相似模式的比较"></a>2.3、相似模式的比较</h2><p>既然获得引用就可以做一些扩展之类的事情，这点跟装饰者模式、适配器模式看起来很像，三者都属于结构型模式，但是代理模式核心是为其它对象提供一种代理以控制对这个对象的访问()</p>
<blockquote>
<p>代理模式 VS 适配器模式</p>
</blockquote>
<p>看上去很像，它们都可视为一个对象提供一种前置的接口，但是适配器模式的用意是改变所考虑的对象的接口，而代理模式并不能改变所代理的对象的接口，这一点上两个模式有着明显的区别，下图分别是 对象适配器和类的适配器UML图</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9a53c4a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<blockquote>
<p>代理模式VS 装饰模式</p>
</blockquote>
<p>装饰者模式与所装饰的对象有着相同的接口，这一点跟代理模式相同，但是装饰模式更强调为所装饰的对象提供增强功能，而代理模式则是对对象的使用施加控制，并不提供对象本身的增强功能；被代理对象由代理对象创建，客户端甚至不需要知道被代理类的存在；被装饰对象由客户端创建并传给装饰对象。装饰者UML图如下</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/22/16915a41d9bb2a1a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<p>你以为这就完了吗？下面👇才是重头戏！</p>
<h1 id="三、深入理解动态代理"><a href="#三、深入理解动态代理" class="headerlink" title="三、深入理解动态代理"></a>三、深入理解动态代理</h1><h2 id="3-1、什么是动态代理"><a href="#3-1、什么是动态代理" class="headerlink" title="3.1、什么是动态代理"></a>3.1、什么是动态代理</h2><p>代理类在程序运行时创建的代理方式被成为 动态代理。即代理类并不是在代码中定义的，而是在运行时根据我们在Java代码中”规定”的信息自动生成。静态代理容易造成代码的膨胀，。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 还是以上面的卖面膜微商为例，她在进货市场进行一番比较之后再决定代理哪个品牌的面膜。</p>
<h2 id="3-2、如何使用动态代理"><a href="#3-2、如何使用动态代理" class="headerlink" title="3.2、如何使用动态代理"></a>3.2、如何使用动态代理</h2><p>跟上文一样，微商和面膜工厂都实现了sell接口，这里就不赘述了，下面看下与众不同的地方，实现动态代理需要实现InvocationHandler接口</p>
<blockquote>
<p>实现InvocationHandler接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    private Object object;//被引用的代理</span><br><span class="line"></span><br><span class="line">    public Object newProxyInstance(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;代理商 包装发朋友圈&quot;);</span><br><span class="line">        Object result = method.invoke(object,args);</span><br><span class="line">        System.out.println(&quot;代理商 赚钱&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>target 属性表示委托类对象</li>
<li><code>InvocationHandler</code>是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个 invoke函数需要实现</li>
<li>invoke函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面好好看看这个核心函数的参数含义</p>
<ul>
<li>proxy 代通过dynamicproxy.newProxyInstance(business)自动生成的代理类 $Proxy0.class(下文会详细介绍)</li>
<li>method表示代理对象被调用的函数，比如sellMask接口里面的sell方法</li>
<li>args 表示代理大力调用函数的的参数，这里sell方法无参数</li>
</ul>
<p>调用代理对象的每个函数，实际上最终都是走到InvocationHandler的invoke函数，因此可以在这里做一些统一的处理，AOP的雏形就慢慢出现了，我们也可以根据method方法名做一些判断，从而实现对某些函数的特殊处理。</p>
<blockquote>
<p>使用动态代理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;)  //加入这个可以获取代理类</span><br><span class="line"></span><br><span class="line">    var maskFactory = FactoryMaskOne()</span><br><span class="line"></span><br><span class="line">    var dynamicproxy: DynamicProxy = DynamicProxy()</span><br><span class="line"></span><br><span class="line">    var sellMask: SellMask = dynamicproxy.newProxyInstance(maskFactory) as SellMask</span><br><span class="line"></span><br><span class="line">    sellMask.sell()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们将委托类面膜工程FactoryMaskOne传到dynamicproxy.newProxyInstance中，通过下面的函数返回了一个代理对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object newProxyInstance(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>实际代理类就是在这个时候动态生成的，后续调用到这个代理类的函数就会直接调用invoke函数，让我们细细看下这个Proxy.newProxyInstance</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>法的三个参数含义分别如下：</p>
<ul>
<li>loader：定义了代理类的ClassLoder;</li>
<li>interfaces：代理类实现的接口列表</li>
<li>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例</li>
</ul>
<p>这里简单总结一下，委托类通过*<em>newProxyInstance *</em>方法获取动态生成的代理类的实例(本例是$Proxy0.class),然后可以通过这个代理类实例调用代理的方法获得委托类的控制权，对代理类的调用实际上都会走到invoke方法，在这里我们调用委托类的相应方法，并且可以添加自己的一些逻辑，比如统一处理登陆、校验之类的。</p>
<h2 id="3-3、动态生成的代理类-Proxy0"><a href="#3-3、动态生成的代理类-Proxy0" class="headerlink" title="3.3、动态生成的代理类$Proxy0"></a>3.3、动态生成的代理类$Proxy0</h2><p>在Android Studio中调用不了<code>ProxyGenerator</code>这个类,这个类在sun.misc包中,使用IntelliJ IDE创建java工程，需要看一下<a href="https://juejin.im/post/5c70094051882562a12aec51" target="_blank" rel="noopener">jdk</a>的反射中Proxy和生成的代理类$Proxy0的源码，可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//生成$Proxy0的class文件</span><br><span class="line">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>生成的代理类在com.sun.proxy包里面完整代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public final class $Proxy0 extends Proxy implements SellMask &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    public final void sell() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //可以看到接口方法都交由h的invoke方法处理，h在父类Proxy中定义为InvocationHandler接口</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Integer)super.h.invoke(this, m0, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m3 = Class.forName(&quot;dev.proxy.SellMask&quot;).getMethod(&quot;sell&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从生成的代理类中可以看到</p>
<ul>
<li>动态生成的代理类是以<code>$Proxy</code>为类名前缀，继承自<code>Proxy</code>，并且实现了<code>Proxy.newProxyInstance(…)</code>第二个参数传入的所有接口的类。</li>
<li>接口方法都交由h的invoke方法处理，h在父类Proxy中定义为InvocationHandler接口，为Proxy.newProxyInstance(…)的第三个参数</li>
</ul>
<h2 id="3-4-动态代理类如何生成"><a href="#3-4-动态代理类如何生成" class="headerlink" title="3.4 动态代理类如何生成"></a>3.4 动态代理类如何生成</h2><ul>
<li>关注点1 Proxy.newProxyInstance(……)函数</li>
</ul>
<p>动态代理类是在调用 Proxy.newProxyInstance(……)函数时生成的，精简后的核心代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        ……</span><br><span class="line">        /*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         * 得到动态代理类</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">            ……</span><br><span class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih = h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            //然后将InvocationHandler作为代理类构造函数入参新建代理类对象</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">           ……</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到 首先调用它先调用<code>getProxyClass(loader, interfaces)</code>得到动态代理类，然后将<code>InvocationHandler</code>作为代理类构造函数入参新建代理类对象。</p>
<ul>
<li>关注点2 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</li>
</ul>
<p>如何获取到 生成动态代理类呢，一步步追踪，我们发现，在Proxy#ProxyClassFactory类中，在ProxyGenerator中去生成动态代理，类名以$Proxy+num作为标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">						/*</span><br><span class="line">             * Generate the specified proxy class.</span><br><span class="line">             */</span><br><span class="line">            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line">            try &#123;</span><br><span class="line">                return defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">            &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">                throw new IllegalArgumentException(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇主要java中的代理模式以及跟其他模式的对比，并重点介绍了JDK中的动态代理机制，像AOP、retrofit核心机制之一就使用到了这种技术，但Java动态代理是基于接口的，如果对象没有实现接口我们该如何代理呢？那就需要CGLIB了，<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，这里就不展开赘述了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://juejin.im/post/5a99048a6fb9a028d5668e62" target="_blank" rel="noopener">juejin.im/post/5a9904…</a></li>
<li><a href="https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a" target="_blank" rel="noopener">juejin.im/post/5ad3e6…</a></li>
<li><a href="http://www.cnblogs.com/xiaoluo501395377/p/3383130.html" target="_blank" rel="noopener">www.cnblogs.com/xiaoluo5013…</a></li>
<li><a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">www.zhihu.com/question/20…</a></li>
<li><a href="https://blog.csdn.net/qq_27095957/article/details/80184291" target="_blank" rel="noopener">blog.csdn.net/qq_27095957…</a></li>
<li>[a.codekk.com/detail/Andr…](<a href="http://a.codekk.com/detail/Android/Caij/公共技术点之" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/Caij/公共技术点之</a> Java 动态代理)</li>
<li><a href="https://www.jianshu.com/p/0391a8e93d3d" target="_blank" rel="noopener">www.jianshu.com/p/0391a8e93…</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/09/23/设计模式精简图册/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/23/设计模式精简图册/" class="post-title-link" itemprop="url">设计模式精简图册</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-23 20:50:20" itemprop="dateCreated datePublished" datetime="2019-09-23T20:50:20+08:00">2019-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 14:32:29" itemprop="dateModified" datetime="2019-12-31T14:32:29+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id><a href="#" class="headerlink" title></a></h2><h1 id="设计模式精简图册"><a href="#设计模式精简图册" class="headerlink" title="设计模式精简图册"></a>设计模式精简图册</h1><p><a href="https://juejin.im/post/5c6c24e5f265da2dce1f3ab8" target="_blank" rel="noopener">来源</a></p>
<blockquote>
<p>首发于我的公众号</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU5OTgzNzM0NA==&mid=2247483802&idx=1&sn=18e83f219111ce13a057ec41dba6a0d4&chksm=feaf9e55c9d81743ffb1d265ea3085c209b02e9ca500d68f815d0727c0d73316023ec3a36768&token=1810700630&lang=zh_CN#rd" target="_blank" rel="noopener">设计模式图册</a></p>
</blockquote>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创建型模式："><a href="#创建型模式：" class="headerlink" title="创建型模式："></a>创建型模式：</h3><p>主要用于创建对象，包括</p>
<ul>
<li>工厂方法(Factory Method)</li>
<li>抽象工厂(Abstract Factory)</li>
<li>单例(Singleton)</li>
<li>生成器(Builder)</li>
<li>原型(Prototype)</li>
</ul>
<h3 id="结构型模式："><a href="#结构型模式：" class="headerlink" title="结构型模式："></a>结构型模式：</h3><p>用于处理类或者对象的组合，包括</p>
<ul>
<li>适配器(Adapter)</li>
<li>装饰者(Decorator)</li>
<li>代理(Proxy)</li>
<li>外观(Facade)</li>
<li>桥接(Bridge Pattern)</li>
<li>组合(Composite)</li>
<li>轻量(Flyweigh)</li>
</ul>
<h3 id="行为型模式："><a href="#行为型模式：" class="headerlink" title="行为型模式："></a>行为型模式：</h3><p>用于描述类与对象怎样的交互和分配职责，包括</p>
<ul>
<li>策略(Strategy)</li>
<li>观察者(Observer)</li>
<li>命令(Command)</li>
<li>模板方法(Template Method)</li>
<li>迭代器(Iterator)</li>
<li>状态(State)</li>
<li>责任链(Chain)</li>
<li>解释器(Interpreter)</li>
<li>中介者(Mediator)</li>
<li>备忘录(Memo)</li>
<li>访问者(Visitor)</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="单一职责原则-Single-responsibility-principle"><a href="#单一职责原则-Single-responsibility-principle" class="headerlink" title="单一职责原则(Single responsibility principle)"></a>单一职责原则(Single responsibility principle)</h3><ul>
<li>核心 不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</li>
<li>问题产生 类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</li>
<li>解决方案 遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</li>
</ul>
<p>但是由于职责扩散会导致在实际中往往会有悖于单一职责</p>
<h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle LSP)"></a>里氏代换原则(Liskov Substitution Principle LSP)</h3><ul>
<li>核心 所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li>问题产生 有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</li>
<li>解决方案 当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</li>
</ul>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p>
<h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><ul>
<li>核心 不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li>
<li>问题产生 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</li>
<li>解决方案 将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</li>
</ul>
<p>接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
<p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>
<h3 id="迪米特原则-Law-of-Demeter-Least-Knowledge-Principle"><a href="#迪米特原则-Law-of-Demeter-Least-Knowledge-Principle" class="headerlink" title="迪米特原则(Law of Demeter/Least Knowledge Principle )"></a>迪米特原则(Law of Demeter/Least Knowledge Principle )</h3><ul>
<li>核心 迪米特法则又叫最少知道原则，一个对象应该对其他对象保持最少的了解。</li>
<li>问题产生 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</li>
<li>解决方案 尽量降低类与类之间的耦合。</li>
</ul>
<p>通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息， 迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p>
<h3 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h3><ul>
<li>核心 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</li>
<li>问题产生 类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</li>
<li>解决方案 将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</li>
</ul>
<p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p>
<p>依赖倒置原则的核心思想是面向接口编程，</p>
<h3 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open Close Principle)"></a>开闭原则(Open Close Principle)</h3><ul>
<li>核心 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</li>
<li>问题产生 在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</li>
<li>解决方案 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li>
</ul>
<p>开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>
<h2 id="几个原则的关联性"><a href="#几个原则的关联性" class="headerlink" title="几个原则的关联性"></a>几个原则的关联性</h2><p>用抽象构建框架，用实现扩展细节的注意事项而已：</p>
<ul>
<li>单一职责原则告诉我们实现类要职责单一；</li>
<li>里氏替换原则告诉我们不要破坏继承体系；</li>
<li>依赖倒置原则告诉我们要面向接口编程；</li>
<li>接口隔离原则告诉我们在设计接口的时候要精简单一；</li>
<li>迪米特法则告诉我们要降低耦合。 而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</li>
</ul>
<h2 id="创建型设计模式-创建对象"><a href="#创建型设计模式-创建对象" class="headerlink" title="创建型设计模式(创建对象)"></a>创建型设计模式(创建对象)</h2><h3 id="工厂方法-Factory-Method-Pattern"><a href="#工厂方法-Factory-Method-Pattern" class="headerlink" title="工厂方法(Factory Method Pattern)"></a>工厂方法(Factory Method Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Factory Method</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td><img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce5cc3db?imageslim" alt="img"></td>
</tr>
<tr>
<td>动机</td>
<td>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</td>
</tr>
<tr>
<td>适用性</td>
<td>当一个类不知道它所必须创建的对象的类的时候。当一个类希望由它的子类来指定它所创建的对象的时候。当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</td>
</tr>
<tr>
<td>优点</td>
<td>在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。</td>
</tr>
<tr>
<td>缺点</td>
<td>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</td>
</tr>
<tr>
<td>小结</td>
<td>简单工厂模式的要点就在于当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，但是如果产品过多时，会导致工厂代码非常复杂。</td>
</tr>
</tbody></table>
<h3 id="抽象工厂-Abstract-Factory-Pattern"><a href="#抽象工厂-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂(Abstract Factory Pattern)"></a>抽象工厂(Abstract Factory Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Abstract Factory</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td><img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffce813741?imageslim" alt="img"></td>
</tr>
<tr>
<td>动机</td>
<td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</td>
</tr>
<tr>
<td>适用性</td>
<td>一个系统要独立于它的产品的创建、组合和表示时。一个系统要由多个产品系列中的一个来配置时。当你要强调一系列相关的产品对象的设计以便进行联合使用时。当你提供一个产品类库，而只想显示它们的接口而不是实现时。</td>
</tr>
<tr>
<td>优点</td>
<td>抽象工厂隔离了具体类的生成，是的客户端不需要知道什么被创建。所有的具体工厂都实现了抽象工厂中定义的公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</td>
</tr>
<tr>
<td>缺点</td>
<td>添加新的行为时比较麻烦。如果需要添加一个新产品族对象时，需要更改接口及其下所有子类，这必然会带来很大的麻烦。</td>
</tr>
<tr>
<td>小结</td>
<td>抽象工厂模式中主要的优点在于具体类的隔离，是的客户端不需要知道什么被创建了。其缺点在于增加新的等级产品结构比较复杂，需要修改接口及其所有子类。</td>
</tr>
</tbody></table>
<h3 id="生成器-建造者模式-Builder-Pattern"><a href="#生成器-建造者模式-Builder-Pattern" class="headerlink" title="生成器/建造者模式(Builder Pattern)"></a>生成器/建造者模式(Builder Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Builder</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td><img src="https://user-gold-cdn.xitu.io/2019/2/19/169066ffcfb3a6e6?imageslim" alt="img"></td>
</tr>
<tr>
<td>动机</td>
<td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</td>
</tr>
<tr>
<td>适用性</td>
<td>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。当构造过程必须允许被构造的对象有不同的表示时。</td>
</tr>
<tr>
<td>优点</td>
<td>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，使得我们能够更加精确的控制复杂对象的产生过程。将产品的创建过程与产品本身分离开来，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</td>
</tr>
<tr>
<td>缺点</td>
<td>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</td>
</tr>
<tr>
<td>小结</td>
<td>建造者模式是将一个复杂对象的创建过程给封装起来，客户只需要知道可以利用对象名或者类型就能够得到一个完整的对象实例，而不需要关心对象的具体创建过程。建造者模式将对象的创建过程与对象本身隔离开了，使得细节依赖于抽象，符合依赖倒置原则。可以使用相同的创建过程来创建不同的产品对象。</td>
</tr>
</tbody></table>
<h3 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式(Prototype Pattern)"></a>原型模式(Prototype Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Prototype</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="518" height="242"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</td>
</tr>
<tr>
<td>适用性</td>
<td>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时；或者当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</td>
</tr>
<tr>
<td>优点</td>
<td>如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。可以使用深克隆保持对象的状态。原型模式提供了简化的创建结构。</td>
</tr>
<tr>
<td>缺点</td>
<td>在实现深克隆的时候可能需要比较复杂的代码。需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</td>
</tr>
<tr>
<td>小结</td>
<td>原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。克隆分为浅克隆和深克隆两种。我们虽然可以利用原型模式来获得一个新对象，但有时对象的复制可能会相当的复杂，比如深克隆。</td>
</tr>
</tbody></table>
<h3 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Singleton</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="394" height="146"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</td>
</tr>
<tr>
<td>适用性</td>
<td>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</td>
</tr>
<tr>
<td>优点</td>
<td>节约了系统资源。由于系统中只存在一个实例对象，对与一些需要频繁创建和销毁对象的系统而言，单 例模式无疑节约了系统资源和提高了系统的性能。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</td>
</tr>
<tr>
<td>缺点</td>
<td>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。单例类的职责过重，在一定程度上违背了“单一职责原则”。</td>
</tr>
<tr>
<td>小结</td>
<td>单例模式中确保程序中一个类最多只有一个实例。单例模式的构造器是私有了，而且它必须要提供实例的全局访问点。单例模式可能会因为多线程的问题而带来安全隐患。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BetterSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private BetterSingleton2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BetterSingleton getInstance() &#123;</span><br><span class="line">        return Singleton.BETTER_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Singleton&#123;</span><br><span class="line">      private static final  BetterSingleton BETTER_SINGLETON = new BetterSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="创建型设计模式小结"><a href="#创建型设计模式小结" class="headerlink" title="创建型设计模式小结"></a>创建型设计模式小结</h3><table>
<thead>
<tr>
<th align="left"><strong>模式</strong></th>
<th>场景发散</th>
<th align="left"><strong>一句话概括</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">工厂方法(Factory Method)</td>
<td>new太多如何管理</td>
<td align="left">生产系列产品。</td>
</tr>
<tr>
<td align="left">抽象工厂(Abstract Factory)</td>
<td>new太多如何管理</td>
<td align="left">一次生产多个不同产品。</td>
</tr>
<tr>
<td align="left">生成器(Builder)</td>
<td>车手选车</td>
<td align="left">生产有很多组件的产品。</td>
</tr>
<tr>
<td align="left">原型(Prototype)</td>
<td>复制不能很难</td>
<td align="left">克隆对象。</td>
</tr>
<tr>
<td align="left">单件(Singleton)</td>
<td>如何管理全局信息</td>
<td align="left">全局只有一个。</td>
</tr>
</tbody></table>
<h2 id="结构型设计模式-处理类或者对象的组合"><a href="#结构型设计模式-处理类或者对象的组合" class="headerlink" title="结构型设计模式(处理类或者对象的组合)"></a>结构型设计模式(处理类或者对象的组合)</h2><h3 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式(Bridge Pattern)"></a>桥接模式(Bridge Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Bridge</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="600" height="246"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</td>
</tr>
<tr>
<td>适用性</td>
<td>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</td>
</tr>
<tr>
<td>优点</td>
<td>分离抽象接口及其实现部分。提高了比继承更好的解决方案。桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。实现细节对客户透明，可以对用户隐藏实现细节。</td>
</tr>
<tr>
<td>缺点</td>
<td>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</td>
</tr>
<tr>
<td>小结</td>
<td>桥接模式实现了抽象化与实现化的脱耦。他们两个互相独立，不会影响到对方。对于两个独立变化的维度，使用桥接模式再适合不过了。对于“具体的抽象类”所做的改变，是不会影响到客户。</td>
</tr>
</tbody></table>
<h3 id="轻量模式-享元模式-FlyWeightPattern"><a href="#轻量模式-享元模式-FlyWeightPattern" class="headerlink" title="轻量模式/享元模式(FlyWeightPattern)"></a>轻量模式/享元模式(FlyWeightPattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Flyweight</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="598" height="369"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>运用共享技术有效地支持大量细粒度的对象。</td>
</tr>
<tr>
<td>适用性</td>
<td>一个应用程序使用了大量的对象。完全由于使用大量的对象，造成很大的存储开销。对象的大多数状态都可变为外部状态。如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。应用程序不依赖于对象标识。由于F l y w e i g h t 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。</td>
</tr>
<tr>
<td>优点</td>
<td>享元模式的优点在于它能够极大的减少系统中对象的个数。享元模式由于使用了外部状态，外部状态相对独立，不会影响到内部状态，所以享元模式使得享元对象能够在不同的环境被共享。</td>
</tr>
<tr>
<td>缺点</td>
<td>由于享元模式需要区分外部状态和内部状态，使得应用程序在某种程度上来说更加复杂化了。为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</td>
</tr>
<tr>
<td>小结</td>
<td>享元模式可以极大地减少系统中对象的数量。但是它可能会引起系统的逻辑更加复杂化。享元模式的核心在于享元工厂，它主要用来确保合理地共享享元对象。内部状态为不变共享部分，存储于享元享元对象内部，而外部状态是可变部分，它应当由客户端来负责。</td>
</tr>
</tbody></table>
<h3 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式(Facade Pattern)"></a>外观模式(Facade Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Facade</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="476" height="185"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>为子系统中的一组接口提供一个一致的界面，F a c a d e 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</td>
</tr>
<tr>
<td>适用性</td>
<td>当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。F a c a d e 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过f a c a d e 层。客户程序与抽象类的实现部分之间存在着很大的依赖性。引入f a c a d e 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。当你需要构建一个层次结构的子系统时，使用f a c a d e 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过f a c a d e 进行通讯，从而简化了它们之间的依赖关系。</td>
</tr>
<tr>
<td>优点</td>
<td>引入外观模式，是客户对子系统的使用变得简单了，减少了与子系统的关联对象，实现了子系统与客户之间的松耦合关系。只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</td>
</tr>
<tr>
<td>缺点</td>
<td>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</td>
</tr>
<tr>
<td>小结</td>
<td>外观模式的主要优点就在于减少了客户与子系统之间的关联对象，使用客户对子系统的使用变得简单了，也实现了客户端与子系统之间的松耦合关系。它的缺点就在于违背了“开闭原则”。如果需要实现一个外观模式，需要将子系统组合进外观中，然后将工作委托给子系统执行。</td>
</tr>
</tbody></table>
<h3 id="装饰者模式-Decorator-Pattern"><a href="#装饰者模式-Decorator-Pattern" class="headerlink" title="装饰者模式(Decorator Pattern)"></a>装饰者模式(Decorator Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Decorator</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="645" height="285"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>动态地给一个对象添加一些额外的职责。就增加功能来说，D e c o r a t o r 模式相比生成子类更为灵活。</td>
</tr>
<tr>
<td>适用性</td>
<td>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。处理那些可以撤消的职责。当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</td>
</tr>
<tr>
<td>优点</td>
<td>装饰者模式可以提供比继承更多的灵活性可以通过一种动态的方式来扩展一个对象的功能，在运行时选择不同的装饰器，从而实现不同的行为。通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</td>
</tr>
<tr>
<td>缺点</td>
<td>会产生很多的小对象，增加了系统的复杂性这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</td>
</tr>
<tr>
<td>小结</td>
<td>装饰者模式意味着一群装饰者类，这些类用来包装具体组件装饰者可以在被装饰者的行为前面或者后面加上自己的行为，甚至可以将被装饰者的行为整个取代掉，从而达到特定的目的。可以用多个装饰者包装一个组件。装饰者一般对于组件的客户是透明的，除非客户程序依赖于组件的具体类型。装饰者会导致设计中出现许多的小对象，如果过度的使用，会让系统变得更加复杂。装饰者和被装饰者对象有相同的超类型。</td>
</tr>
</tbody></table>
<h3 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式(Composite Pattern)"></a>组合模式(Composite Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Composite</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="571" height="257"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>将对象组合成树形结构以表示?部分-整体?的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。</td>
</tr>
<tr>
<td>适用性</td>
<td>你想表示对象的部分-整体层次结构。你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</td>
</tr>
<tr>
<td>优点</td>
<td>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。</td>
</tr>
<tr>
<td>缺点</td>
<td>使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联，会有冗余代码</td>
</tr>
<tr>
<td>小结</td>
<td>组合模式用于将多个对象组合成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。组合对象的关键在于它定义了一个抽象构建类，它既可表示叶子对象，也可表示容器对象，客户仅仅需要针对这个抽象构建进行编程，无须知道他是叶子对象还是容器对象，都是一致对待。组合模式虽然能够非常好地处理层次结构，也使得客户端程序变得简单，但是它也使得设计变得更加抽象，而且也很难对容器中的构件类型进行限制，这会导致在增加新的构件时会产生一些问题。</td>
</tr>
</tbody></table>
<h3 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式(Proxy Pattern)"></a>代理模式(Proxy Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Proxy</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="540" height="226"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>为其他对象提供一种代理以控制对这个对象的访问。</td>
</tr>
<tr>
<td>适用性</td>
<td>不希望某些类被直接访问。访问之前希望先进行一些预处理。希望对被访问的对象进行内存、权限等方面的控制。 模式。</td>
</tr>
<tr>
<td>优点</td>
<td>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的</td>
</tr>
<tr>
<td>缺点</td>
<td>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</td>
</tr>
<tr>
<td>小结</td>
<td>代理模式是通过使用引用代理对象来访问真实对象，在这里代理对象充当用于连接客户端和真实对象的中介者。代理模式主要用于远程代理、虚拟代理和保护代理。其中保护代理可以进行访问权限控制。</td>
</tr>
</tbody></table>
<h3 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Adapter</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="524" height="197"/>)<code>动机              将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。                  适用性                                你想使用一个已经存在的类，而它的接口不符合你的需求。                          你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。                          （仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。                                优点                                将目标类和适配者类解耦，通过使用适配器让不兼容的接口变成了兼容，让客户从实现的接口解耦。                          增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。                          灵活性和扩展性都非常好在不修改原有代码的基础上增加新的适配器类，符合“开闭原则”。                                缺点                                过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。                          因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。                                小结                                当我们需要使用的一个现有的类，但是他的接口并不符合我们的需求时，我们可以使用适配器模式。                          适配器模式分为类适配器和对象适配器，其中类适配器需要用到多重继承。                     复制代码</code></td>
</tr>
</tbody></table>
<h3 id="结构型设计模式小结"><a href="#结构型设计模式小结" class="headerlink" title="结构型设计模式小结"></a>结构型设计模式小结</h3><table>
<thead>
<tr>
<th align="left">模式</th>
<th>场景发散</th>
<th align="left">一句话说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">桥(Bridge)</td>
<td>麻烦的日志记录</td>
<td align="left">将“抽象”和“实现”自由搭配。</td>
</tr>
<tr>
<td align="left">轻量(Flyweight)</td>
<td>森林里的树太多了</td>
<td align="left">轻松地处理“大量”对象。</td>
</tr>
<tr>
<td align="left">外观(Façade)</td>
<td>超级手机</td>
<td align="left">同时提供简单接口和复杂接口。</td>
</tr>
<tr>
<td align="left">装饰者(Decorator)</td>
<td>星巴克的饮料计较系统</td>
<td align="left">不改变接口但要增强功能。</td>
</tr>
<tr>
<td align="left">组合(Composite)</td>
<td>超酷的绘图软件</td>
<td align="left">不管你是老子还是儿子，都一样处理。</td>
</tr>
<tr>
<td align="left">代理(Proxy)</td>
<td>找中介租房</td>
<td align="left">代理要控制你的访问，同时让你的访问更舒服 。</td>
</tr>
<tr>
<td align="left">适配器(Adapter)</td>
<td>老掉牙系统的重生</td>
<td align="left">不改变功能但要改变接口</td>
</tr>
</tbody></table>
<h2 id="行为型设计模式-类与对象怎样的交互和分配职责"><a href="#行为型设计模式-类与对象怎样的交互和分配职责" class="headerlink" title="行为型设计模式(类与对象怎样的交互和分配职责)"></a>行为型设计模式(类与对象怎样的交互和分配职责)</h2><h3 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式(Observer Pattern)"></a>观察者模式(Observer Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Observer</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="615" height="243"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</td>
</tr>
<tr>
<td>适用性</td>
<td>当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</td>
</tr>
<tr>
<td>优点</td>
<td>当两个对象之间送耦合，他们依然可以交互，但是不太清楚彼此的细节。观察者模式提供了一种对象设计，让主题和观察者之间送耦合。主题所知道只是一个具体的观察者列表，每一个具体观察者都符合一个抽象观察者的接口。主题并不认识任何一个具体的观察者，它只知道他们都有一个共同的接口。观察者模式支持“广播通信”。主题会向所有的观察者发出通知。观察者模式符合“开闭原则”的要求。</td>
</tr>
<tr>
<td>缺点</td>
<td>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进 行循环调用，可能导致系统崩溃。观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</td>
</tr>
<tr>
<td>小结</td>
<td>观察者模式定义了对象之间的一对多关系。多个观察者监听同一个被观察者，当该被观察者的状态发生改变时，会通知所有的观察者。观察者模式中包含四个角色。主题，它指被观察的对象。具体主题是主题子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者，将对观察主题的改变做出反应；具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</td>
</tr>
</tbody></table>
<h3 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式(Strategy Pattern)"></a>策略模式(Strategy Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Strategy</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="539" height="186"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</td>
</tr>
<tr>
<td>适用性</td>
<td>许多相关的类仅仅是行为有异。策略模式提供了一种用多个行为中的一个行为来配置一个类的方法。需要使用一个算法的不同变体。算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的S t r a t e g y 类中以代替这些条件语句。</td>
</tr>
<tr>
<td>优点</td>
<td>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。策略模式提供了可以替换继承关系的办法。使用策略模式可以避免使用多重条件转移语句。</td>
</tr>
<tr>
<td>缺点</td>
<td>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。策略模式将造成产生很多策略类，</td>
</tr>
<tr>
<td>小结</td>
<td>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。一个系统需要动态地在几种算法中选择一种。如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</td>
</tr>
</tbody></table>
<h3 id="迭代器模式-Iterator-Pattern"><a href="#迭代器模式-Iterator-Pattern" class="headerlink" title="迭代器模式(Iterator Pattern)"></a>迭代器模式(Iterator Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Iterator</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="560" height="276"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</td>
</tr>
<tr>
<td>适用性</td>
<td>访问一个聚合对象的内容而无需暴露它的内部表示。支持对聚合对象的多种遍历。为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。</td>
</tr>
<tr>
<td>优点</td>
<td>它支持以不同的方式遍历一个聚合对象。迭代器简化了聚合类。在同一个聚合上可以有多个遍历。在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</td>
</tr>
<tr>
<td>缺点</td>
<td>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</td>
</tr>
<tr>
<td>小结</td>
<td>将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。迭代器模式是“单一职责原则”的完美体现。当使用迭代器的时候，我们依赖聚合提供遍历。迭代器提供了一个通用的接口，让我们遍历聚合的项，放我们编码使用聚合项时，就可以使用多态机制。</td>
</tr>
</tbody></table>
<h3 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式(Command Pattern)"></a>命令模式(Command Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Command</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="603" height="212"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。</td>
</tr>
<tr>
<td>适用性</td>
<td>抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（c a l l b a c k ）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。C o m m a n d 模式是回调机制的一个面向对象的替代品。在不同的时刻指定、排列和执行请求。一个C o m m a n d 对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。支持取消操作。C o m m a n d 的E x c u t e 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。C o m m a n d 接口必须添加一个U n e x e c u t e 操作，该操作取消上一次E x e c u t e 调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用U n e x e c u t e 和E x e c u t e 来实现重数不限的取消和重做。支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在C o m m a n d 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用E x e c u t e 操作重新执行它们。用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( t r a n s a c t i o n )的信息系统中很常见。一个事务封装了对数据的一组变动。C o m m a n d 模式提供了对事务进行建模的方法。C o m m a n d 有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。</td>
</tr>
<tr>
<td>优点</td>
<td>降低了系统耦合度新的命令可以很容易添加到系统中去。</td>
</tr>
<tr>
<td>缺点</td>
<td>使用命令模式可能会导致某些系统有过多的具体命令类。</td>
</tr>
<tr>
<td>小结</td>
<td>命令模式的本质就是将命令对象进行封装打包，将发出命令的责任和执行命令的责任进行割开。命令模式中发送者只需要知道如何发送请求命令，无须关心命令执行具体过程。在发送者和接收者两者间是通过命令对象进行沟通的。请求命令本身就当做一个对象在两者间进行传递，它封装了接收者和一组动作。命令模式支持撤销。命令模式队列请求和日志请求。</td>
</tr>
</tbody></table>
<h3 id="访问者模式-Visitor-Pattern"><a href="#访问者模式-Visitor-Pattern" class="headerlink" title="访问者模式(Visitor Pattern)"></a>访问者模式(Visitor Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Visitor</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="536" height="417"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</td>
</tr>
<tr>
<td>适用性</td>
<td>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作?污染?这些对象的类。Vi s i t o r 使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Vi s i t o r 模式让每个应用仅包含需要用到的操作。定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</td>
</tr>
<tr>
<td>优点</td>
<td>使得新增新的访问操作变得更加简单。能够使得用户在不修改现有类的层次结构下，定义该类层次结构的操作。将有关元素对象的访问行为集中到一个访问者对象中，而不是分散搞一个个的元素类中。</td>
</tr>
<tr>
<td>缺点</td>
<td>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了“开闭原则”的要求。破坏封装。当采用访问者模式的时候，就会打破组合类的封装。</td>
</tr>
<tr>
<td>小结</td>
<td>1.SomeClass 的 Accept()方法就是访问原来类的小口， Accept()方法只有一句代码，就是: visitor.NewMethod(this) ，这是访问者模式的精妙之处。 2.SomeClass 的新功能通过实现 IVisitor 接口的类来实现。访问者模式封装了对象结构元素之上的操作，使得新增元素的操作变得非常简单。所以它比较适用于那么对象结构很少变化的类。访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。</td>
</tr>
</tbody></table>
<h3 id="解释器模式-Interpreter-Pattern"><a href="#解释器模式-Interpreter-Pattern" class="headerlink" title="解释器模式(Interpreter Pattern)"></a>解释器模式(Interpreter Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Interpreter</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="450" height="242"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</td>
</tr>
<tr>
<td>适用性</td>
<td>当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。</td>
</tr>
<tr>
<td>优点</td>
<td>可扩展性比较好，灵活。增加了新的解释表达式的方式。易于实现文法。</td>
</tr>
<tr>
<td>缺点</td>
<td>执行效率比较低，可利用场景比较少。对于复杂的文法比较难维护。</td>
</tr>
<tr>
<td>小结</td>
<td>在解释器模式中由于语法是由很多类表示的，所以可扩展性强。虽然解释器的可扩展性强，但是如果语法规则的数目太大的时候，该模式可能就会变得异常复杂。所以解释器模式适用于文法较为简单的。解释器模式可以处理脚本语言和编程语言。常用于解决某一特定类型的问题频繁发生情况。</td>
</tr>
</tbody></table>
<h3 id="中介者模式-Mediator-Pattern"><a href="#中介者模式-Mediator-Pattern" class="headerlink" title="中介者模式(Mediator Pattern)"></a>中介者模式(Mediator Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Mediator</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="535" height="166"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</td>
</tr>
<tr>
<td>适用性</td>
<td>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。想定制一个分布在多个类中的行为，而又不想生成太多的子类。</td>
</tr>
<tr>
<td>优点</td>
<td>简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使系统成为松耦合系统。减少了子类的生成。可以减少各同事类的设计与实现。</td>
</tr>
<tr>
<td>缺点</td>
<td>由于中介者对象封装了系统中对象之间的相互关系，导致其变得非常复杂，使得系统维护比较困难。</td>
</tr>
<tr>
<td>小结</td>
<td>每个控件不需要直接和别的控件打交道，只需要知道中介者就可以了。每个控件都需要保持保持中介者的引用，而中介者不一定需要保持每个控件的引用Mediator 的代码可能很复杂。</td>
</tr>
</tbody></table>
<h3 id="备忘录模式-Memento-Pattern"><a href="#备忘录模式-Memento-Pattern" class="headerlink" title="备忘录模式(Memento Pattern)"></a>备忘录模式(Memento Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Mediator</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="535" height="166"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</td>
</tr>
<tr>
<td>适用性</td>
<td>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。想定制一个分布在多个类中的行为，而又不想生成太多的子类。</td>
</tr>
<tr>
<td>优点</td>
<td>给用户提供了一种可以恢复状态的机制。可以是用户能够比较方便地回到某个历史的状态。实现了信息的封装。使得用户不需要关心状态的保存细节。</td>
</tr>
<tr>
<td>缺点</td>
<td>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</td>
</tr>
<tr>
<td>小结</td>
<td>到需要保存对象多个状态，并且可以恢复到任意状态，可考虑备忘录模式。将对象、对象状态和状态的保存办法分离，设计上会更加灵活。但对象属性的备份、恢复、保存等动作，都是可能比较耗时的。备忘录模式只是提供了保存对象状态的一种解决方案框架 ，真正应用时还需要解决这些 问题:1.如何设计 Memento? 2.怎样保存多个对象? 3.怎样保存组织成树结构的多个对象?</td>
</tr>
</tbody></table>
<h3 id="模板方法模式-TemplateMethod-Pattern"><a href="#模板方法模式-TemplateMethod-Pattern" class="headerlink" title="模板方法模式(TemplateMethod Pattern)"></a>模板方法模式(TemplateMethod Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Template Method</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="395" height="225"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Te m p l a t e M e t h o d 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</td>
</tr>
<tr>
<td>适用性</td>
<td>算法的骨架是不变的，但其中的步骤实现可能有变化，这时可应用模板方法。</td>
</tr>
<tr>
<td>优点</td>
<td>模板方法模式在定义了一组算法，将具体的实现交由子类负责。模板方法模式是一种代码复用的基本技术。模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”。</td>
</tr>
<tr>
<td>缺点</td>
<td>每一个不同的实现都需要一个子类来实现，导致类的个数增加，是的系统更加庞大。</td>
</tr>
<tr>
<td>小结</td>
<td>模板方法模式定义了算法的步骤，将这些步骤的实现延迟到了子类。模板方法模式为我们提供了一种代码复用的重要技巧。模板方法模式的抽象类可以定义抽象方法、具体方法和钩子。为了防止子类改变算法的实现步骤，我们可以将模板方法声明为final。</td>
</tr>
</tbody></table>
<h3 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式(State Pattern)"></a>状态模式(State Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>State</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="472" height="190"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</td>
</tr>
<tr>
<td>适用性</td>
<td>一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。S t a t e模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</td>
</tr>
<tr>
<td>优点</td>
<td>封装了转换规则。枚举可能的状态，在枚举状态之前需要确定状态种类。将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</td>
</tr>
<tr>
<td>缺点</td>
<td>状态模式的使用必然会增加系统类和对象的个数。状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</td>
</tr>
<tr>
<td>小结</td>
<td>状态模式允许一个对象基于内部状态而拥有不同的行为。Context会将行为委托给当前状态对象。状态模式对“开闭原则”支持不是很好。</td>
</tr>
</tbody></table>
<h3 id="责任链模式-Chain-of-Responsibility-Pattern"><a href="#责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="责任链模式(Chain of Responsibility Pattern)"></a>责任链模式(Chain of Responsibility Pattern)</h3><table>
<thead>
<tr>
<th>名称</th>
<th><strong>Chain of Responsibility</strong></th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="412" height="218"/>)</td>
</tr>
<tr>
<td>动机</td>
<td>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</td>
</tr>
<tr>
<td>适用性</td>
<td>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。可处理一个请求的对象集合应被动态指定。</td>
</tr>
<tr>
<td>优点</td>
<td>降低耦合度。它将请求的发送者和接受者解耦。简化了对象。使得对象不需要知道链的结构。增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。增加新的请求处理类很方便。</td>
</tr>
<tr>
<td>缺点</td>
<td>不能保证请求一定被接收。系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用可能不容易观察运行时的特征，有碍于除错。</td>
</tr>
<tr>
<td>小结</td>
<td>职责链模式将请求的发送者和接受者解耦了。客户端不需要知道请求处理者的明确信息，甚至不需要知道链的结构，它只需要将请求进行发送即可。职责链模式能够非常方便的动态增加新职责或者删除职责。客户端发送的请求可能会得不到处理。处理者不需要知道链的结构，只需要明白他的后续者是谁就可以了。这样就简化了系统中的对象。</td>
</tr>
</tbody></table>
<h3 id="行为型设计模式小结"><a href="#行为型设计模式小结" class="headerlink" title="行为型设计模式小结"></a>行为型设计模式小结</h3><table>
<thead>
<tr>
<th align="left">模式</th>
<th>场景发散</th>
<th align="left">一句话说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">观察者(Observer)</td>
<td>同步更新的问题</td>
<td align="left">一呼百应。</td>
</tr>
<tr>
<td align="left">策略(Strategy)</td>
<td>设计你的战士</td>
<td align="left">分离算法。</td>
</tr>
<tr>
<td align="left">迭代器(Iterator)</td>
<td>集合访问的烦恼</td>
<td align="left">以一致的方式访问集合， “松绑 ”遍历算法代码。</td>
</tr>
<tr>
<td align="left">命令(Command)</td>
<td>神奇的Do与Undo</td>
<td align="left">分离功能调用者与功能实现者。</td>
</tr>
<tr>
<td align="left">访问者(Visitor)</td>
<td>增加新方法的烦恼</td>
<td align="left">不改变对象结构增加新方法。</td>
</tr>
<tr>
<td align="left">解释器(Interpreter)</td>
<td>超级表达解释引擎</td>
<td align="left">语法解释。</td>
</tr>
<tr>
<td align="left">中介者(Mediator)</td>
<td>麻烦的多角关系</td>
<td align="left">处理多对多关系。</td>
</tr>
<tr>
<td align="left">备忘录(Memento)</td>
<td>假如一切可以重来</td>
<td align="left">保存对象的多个状态并可任意恢复。</td>
</tr>
<tr>
<td align="left">模板方法(Template Method)</td>
<td>万能的排序器</td>
<td align="left">定义好框架算法 ，某些步骤可自己定义 。</td>
</tr>
<tr>
<td align="left">状态(State)</td>
<td>是攻击还是逃走</td>
<td align="left">方便地处理不同状态不同行为，以及状态之间的转换。</td>
</tr>
<tr>
<td align="left">责任链(Chain)</td>
<td>邮件自动处理系统</td>
<td align="left">用不同的规则去处理请求。</td>
</tr>
</tbody></table>
<h2 id="模式比较"><a href="#模式比较" class="headerlink" title="模式比较"></a>模式比较</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">www.uml.org.cn/sjms/201211…</a></li>
<li><a href="http://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">www.cnblogs.com/chenssy/p/3…</a></li>
<li><a href="https://academy.realm.io/cn/posts/donn-felker-solid-part-1/" target="_blank" rel="noopener">academy.realm.io/cn/posts/do…</a></li>
<li><a href="http://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">www.cnblogs.com/chenssy/p/3…</a></li>
<li>《硬啃设计模式》</li>
<li>《HeadFirst 设计模式》</li>
<li>GoF 《可复用面向对象软件的基础》</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/09/05/NDK开发Application-mk指南-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/NDK开发Application-mk指南-6/" class="post-title-link" itemprop="url">NDK开发Application.mk指南[6]</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-05 13:39:51" itemprop="dateCreated datePublished" datetime="2019-09-05T13:39:51+08:00">2019-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 10:30:53" itemprop="dateModified" datetime="2019-12-31T10:30:53+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NDK/" itemprop="url" rel="index">
                    <span itemprop="name">NDK</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Application-mk"><a href="#Application-mk" class="headerlink" title="Application.mk"></a>Application.mk</h1><p><a href="https://developer.android.com/ndk/guides/application_mk.html" target="_blank" rel="noopener">官网地址</a></p>
<p>Application.mk<code>指定了 ndk-build 的项目范围设置。默认情况下，它位于应用项目目录中的</code>jni/Application.mk` 下。</p>
<p><strong>注意</strong>：其中许多参数也具有模块等效项。例如，<code>APP_CFLAGS</code> 对应于 <code>LOCAL_CFLAGS</code>。无论何种情况下，特定于模块的选项都将优先于应用范围选项。对于标记，两者都使用，但特定于模块的标记将后出现在命令行中，因此它们可能会替换项目范围设置。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/09/05/NDK开发Application-mk指南-6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/09/05/NDK开发Android-mk指南-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/NDK开发Android-mk指南-5/" class="post-title-link" itemprop="url">NDK开发Android.mk指南[5]</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-05 11:01:05" itemprop="dateCreated datePublished" datetime="2019-09-05T11:01:05+08:00">2019-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 10:30:53" itemprop="dateModified" datetime="2019-12-31T10:30:53+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NDK/" itemprop="url" rel="index">
                    <span itemprop="name">NDK</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h1><p><a href https: developer.android.com ndk guides android_mk.html"">官网链接</a></p>
<p>本页介绍了 <code>ndk-build</code> 所使用的 <code>Android.mk</code> 编译文件的语法。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>Android.mk</code> 文件位于项目 <code>jni/</code> 目录的子目录中，用于向编译系统描述源文件和共享库。它实际上是编译系统解析一次或多次的微小 GNU makefile 片段。<code>Android.mk</code> 文件用于定义 <a href="https://developer.android.com/ndk/guides/application_mk.html" target="_blank" rel="noopener"><code>Application.mk</code></a>、编译系统和环境变量所未定义的项目范围设置。它还可替换特定模块的项目范围设置。</p>
<p><code>Android.mk</code> 的语法支持将源文件分组为模块。模块是静态库、共享库或独立的可执行文件。您可在每个 <code>Android.mk</code> 文件中定义一个或多个模块，也可在多个模块中使用同一个源文件。编译系统只将共享库放入您的应用软件包。此外，静态库可生成共享库。</p>
<p>除了封装库之外，编译系统还可为您处理各种其他事项。例如，您无需在 <code>Android.mk</code> 文件中列出头文件或生成的文件之间的显式依赖关系。NDK 编译系统会自动计算这些关系。因此，您应该能够享受到未来 NDK 版本中新工具链/平台支持带来的益处，而无需处理 <code>Android.mk</code> 文件。</p>
<p>此文件的语法与随整个 <a href="https://source.android.com/" target="_blank" rel="noopener">Android 开源项目</a>分发的 <code>Android.mk</code> 文件中使用的语法非常接近。虽然使用这些语法的编译系统实现并不相同，但通过有意将语法设计得相似，可使应用开发者更轻松地将源代码重复用于外部库。</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>在详细了解语法之前，最好先了解 <code>Android.mk</code> 文件所含内容的基本信息。为此，本部分使用 Hello-JNI 示例中的 <code>Android.mk</code> 文件解释文件中每一行的作用。</p>
<p><code>Android.mk</code> 文件必须先定义 <code>LOCAL_PATH</code> 变量：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br></pre></td></tr></table></figure>

<p>此变量表示源文件在开发树中的位置。在这行代码中，编译系统提供的宏函数 <code>my-dir</code> 将返回当前目录（<code>Android.mk</code> 文件本身所在的目录）的路径。</p>
<p>下一行声明 <code>CLEAR_VARS</code> 变量，其值由编译系统提供。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br></pre></td></tr></table></figure>

<p><code>CLEAR_VARS</code> 变量指向一个特殊的 GNU Makefile，后者会清除许多 <code>LOCAL_XXX</code> 变量，例如 <code>LOCAL_MODULE</code>、<code>LOCAL_SRC_FILES</code> 和 <code>LOCAL_STATIC_LIBRARIES</code>。请注意，GNU Makefile 不会清除 <code>LOCAL_PATH</code>。此变量必须保留其值，因为系统在单一 GNU Make 执行环境（其中的所有变量都是全局变量）中解析所有编译控制文件。在描述每个模块之前，必须声明（重新声明）此变量。</p>
<p>接下来，<code>LOCAL_MODULE</code> 变量存储您要编译的模块的名称。请在应用的每个模块中使用一次此变量。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := hello-jni</span><br></pre></td></tr></table></figure>

<p>每个模块名称必须唯一，且不含任何空格。编译系统在生成最终共享库文件时，会对您分配给 <code>LOCAL_MODULE</code> 的名称自动添加正确的前缀和后缀。例如，上述示例会生成名为 <code>libhello-jni.so</code> 的库。</p>
<p><strong>注意</strong>：如果模块名称的开头已经是 <code>lib</code>，则编译系统不会附加额外的 <code>lib</code> 前缀；而是按原样采用模块名称，并添加 <code>.so</code> 扩展名。因此，比如原来名为 <code>libfoo.c</code> 的源文件仍会生成名为 <code>libfoo.so</code> 的共享对象文件。此行为是为了支持 Android 平台源文件根据 <code>Android.mk</code> 文件生成的库；所有这些库的名称都以 <code>lib</code> 开头。</p>
<p>下一行会列举源文件，以空格分隔多个文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES := hello-jni.c</span><br></pre></td></tr></table></figure>

<p><code>LOCAL_SRC_FILES</code> 变量必须包含要编译到模块中的 C 和/或 C++ 源文件列表。</p>
<p>最后一行帮助系统将所有内容连接到一起：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p><code>BUILD_SHARED_LIBRARY</code> 变量指向一个 GNU Makefile 脚本，该脚本会收集您自最近 <code>include</code> 以来在 <code>LOCAL_XXX</code> 变量中定义的所有信息。此脚本确定要编译的内容以及编译方式。</p>
<p>示例目录中有更为复杂的示例，包括带有注释的 <code>Android.mk</code> 文件供您参考。此外，<a href="https://developer.android.com/ndk/samples/sample_na.html" target="_blank" rel="noopener">示例：native-activity</a> 详细介绍了该示例的 <code>Android.mk</code> 文件。最后，<a href="https://developer.android.com/ndk/guides/android_mk.html#var" target="_blank" rel="noopener">变量和宏</a>提供了关于本部分中变量的更多信息。</p>
<h3 id="变量和宏"><a href="#变量和宏" class="headerlink" title="变量和宏"></a>变量和宏</h3><p>编译系统提供了许多可在 <code>Android.mk</code> 文件中使用的变量。其中许多变量已预先赋值。另一些变量由您赋值。</p>
<p>除了这些变量之外，您还可以自己定义任意变量。在定义变量时请注意，NDK 编译系统保留了下列变量名称：</p>
<ul>
<li>以 <code>LOCAL_</code> 开头的名称，例如 <code>LOCAL_MODULE</code>。</li>
<li>以 <code>PRIVATE_</code>、<code>NDK_</code> 或 <code>APP</code> 开头的名称。编译系统在内部使用这些变量名。</li>
<li>小写名称，例如 <code>my-dir</code>。编译系统也是在内部使用这些变量名。</li>
</ul>
<p>如果您为了方便而需要在 <code>Android.mk</code> 文件中定义自己的变量，建议在名称前附加 <code>MY_</code>。</p>
<h4 id="NDK定义的include变量"><a href="#NDK定义的include变量" class="headerlink" title="NDK定义的include变量"></a>NDK定义的include变量</h4><p>本部分探讨了编译系统在解析 <code>Android.mk</code> 文件前定义的 GNU Make 变量。在某些情况下，NDK 可能会多次解析 <code>Android.mk</code> 文件，每次使用其中某些变量的不同定义。</p>
<h5 id="CLEAR-VARS"><a href="#CLEAR-VARS" class="headerlink" title="CLEAR_VARS"></a>CLEAR_VARS</h5><p>此变量指向的编译脚本用于取消定义下文“开发者定义的变量”部分中列出的几乎所有 <code>LOCAL_XXX</code> 变量。在描述新模块之前，请使用此变量来包含此脚本。使用它的语法为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br></pre></td></tr></table></figure>

<h5 id="BUILD-SHARED-LIBRARY"><a href="#BUILD-SHARED-LIBRARY" class="headerlink" title="BUILD_SHARED_LIBRARY"></a>BUILD_SHARED_LIBRARY</h5><p>此变量指向的编译脚本用于收集您在 <code>LOCAL_XXX</code> 变量中提供的模块的所有相关信息，以及确定如何根据您列出的源文件编译目标共享库。请注意，使用此脚本要求您至少已经为 <code>LOCAL_MODULE</code> 和 <code>LOCAL_SRC_FILES</code> 赋值（要详细了解这些变量，请参阅<a href="https://developer.android.com/ndk/guides/android_mk.html#mdv" target="_blank" rel="noopener">模块描述变量</a>）。</p>
<p>使用此变量的语法为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p>共享库变量会导致编译系统生成扩展名为 <code>.so</code> 的库文件。</p>
<h5 id="BUILD-STATIC-LIBRARY"><a href="#BUILD-STATIC-LIBRARY" class="headerlink" title="BUILD_STATIC_LIBRARY"></a>BUILD_STATIC_LIBRARY</h5><p>用于编译静态库的 <code>BUILD_SHARED_LIBRARY</code> 的变体。编译系统不会将静态库复制到您的项目/软件包中，但可以使用静态库编译共享库（请参阅下文的 <code>LOCAL_STATIC_LIBRARIES</code> 和 <code>LOCAL_WHOLE_STATIC_LIBRARIES</code>）。使用此变量的语法为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p>静态库变量会导致编译系统生成扩展名为 <code>.a</code> 的库。</p>
<h5 id="PUBLIC-SHARED-LIBRARY"><a href="#PUBLIC-SHARED-LIBRARY" class="headerlink" title="PUBLIC_SHARED_LIBRARY"></a>PUBLIC_SHARED_LIBRARY</h5><p>指向用于指定预编译共享库的编译脚本。与 <code>BUILD_SHARED_LIBRARY</code> 和 <code>BUILD_STATIC_LIBRARY</code>的情况不同，这里的 <code>LOCAL_SRC_FILES</code> 值不能是源文件，而必须是指向预编译共享库的一个路径，例如 <code>foo/libfoo.so</code>。使用此变量的语法为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(PREBUILT_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p>您也可以使用 <code>LOCAL_PREBUILTS</code> 变量引用另一个模块中的预编译库。要详细了解如何使用预编译库，请参阅<a href="https://developer.android.com/ndk/guides/prebuilts.html" target="_blank" rel="noopener">使用预编译库</a>。</p>
<h5 id="PUBLIC-STATIC-LIBRARY"><a href="#PUBLIC-STATIC-LIBRARY" class="headerlink" title="PUBLIC_STATIC_LIBRARY"></a>PUBLIC_STATIC_LIBRARY</h5><p>与 <code>PREBUILT_SHARED_LIBRARY</code> 相同，但用于预编译静态库。要详细了解如何使用预编译库，请参阅<a href="https://developer.android.com/ndk/guides/prebuilts.html" target="_blank" rel="noopener">使用预编译库</a>。</p>
<h3 id="目标信息变量"><a href="#目标信息变量" class="headerlink" title="目标信息变量"></a>目标信息变量</h3><p>编译系统会根据 <code>APP_ABI</code> 变量所指定的每个 ABI 解析 <code>Android.mk</code> 一次，该变量通常在 <code>Application.mk</code> 文件中定义。如果 <code>APP_ABI</code> 为 <code>all</code>，则编译系统会根据 NDK 支持的每个 ABI 解析 <code>Android.mk</code> 一次。本部分介绍了编译系统每次解析 <code>Android.mk</code> 时定义的变量。</p>
<h5 id="TARGET-ARCH"><a href="#TARGET-ARCH" class="headerlink" title="TARGET_ARCH"></a>TARGET_ARCH</h5><p>编译系统解析此 <code>Android.mk</code> 文件时面向的 CPU 系列。此变量是 <code>arm</code>、<code>arm64</code>、<code>x86</code> 或 <code>x86_64</code>之一。</p>
<h5 id="TARGET-PLATFORM"><a href="#TARGET-PLATFORM" class="headerlink" title="TARGET_PLATFORM"></a>TARGET_PLATFORM</h5><p>编译系统解析此 <code>Android.mk</code> 文件时面向的 Android API 级别编号。例如，Android 5.1 系统映像对应于 Android API 级别 22：<code>android-22</code>。如需平台名称和对应 Android 系统映像的完整列表，请参阅 <a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="noopener">Android NDK 原生 API</a>。以下示例演示了使用此变量的语法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(TARGET_PLATFORM)</span>,android-22)</span><br><span class="line">        <span class="comment"># ... do something ...</span></span><br><span class="line">    <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h5 id="TARGET-ARCH-ABI"><a href="#TARGET-ARCH-ABI" class="headerlink" title="TARGET_ARCH_ABI"></a>TARGET_ARCH_ABI</h5><p>编译系统解析此 <code>Android.mk</code> 文件时面向的 ABI。表 1 显示用于每个受支持 CPU 和架构的 ABI 设置。</p>
<p><strong>表 1.</strong> 不同 CPU 和架构的 ABI 设置。</p>
<table>
<thead>
<tr>
<th>CPU 和架构</th>
<th>设置</th>
</tr>
</thead>
<tbody><tr>
<td>ARMv7</td>
<td><code>armeabi-v7a</code></td>
</tr>
<tr>
<td>ARMv8 AArch64</td>
<td><code>arm64-v8a</code></td>
</tr>
<tr>
<td>i686</td>
<td><code>x86</code></td>
</tr>
<tr>
<td>x86-64</td>
<td><code>x86_64</code></td>
</tr>
</tbody></table>
<p>以下示例演示了如何检查 ARMv8 AArch64 是否为目标 CPU 与 ABI 的组合：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(TARGET_ARCH_ABI)</span>,arm64-v8a)</span><br><span class="line">      <span class="comment"># ... do something ...</span></span><br><span class="line">    <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>要详细了解架构 ABI 和相关兼容性问题，请参阅 <a href="https://developer.android.com/ndk/guides/abis.html" target="_blank" rel="noopener">ABI 管理</a>。</p>
<p>未来的新目标 ABI 将使用不同的值。</p>
<h5 id="TARGET-ABI"><a href="#TARGET-ABI" class="headerlink" title="TARGET_ABI"></a>TARGET_ABI</h5><p>目标 Android API 级别与 ABI 的连接，特别适用于要针对实际设备测试特定目标系统映像的情况。例如，要检查搭载 Android API 级别 22 的 64 位 ARM 设备：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(TARGET_ABI)</span>,android-22-arm64-v8a)</span><br><span class="line">      <span class="comment"># ... do something ...</span></span><br><span class="line">    <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="模块描述变量"><a href="#模块描述变量" class="headerlink" title="模块描述变量"></a>模块描述变量</h3><p>本部分中的变量会向编译系统描述您的模块。每个模块描述都应遵守以下基本流程：</p>
<ol>
<li>使用 <code>CLEAR_VARS</code> 变量初始化或取消定义与模块相关的变量。</li>
<li>为用于描述模块的变量赋值。</li>
<li>使用 <code>BUILD_XXX</code> 变量设置 NDK 编译系统，使其将适当的编译脚本用于该模块。</li>
</ol>
<h5 id="LOCAL-PATH"><a href="#LOCAL-PATH" class="headerlink" title="LOCAL_PATH"></a>LOCAL_PATH</h5><p>此变量用于指定当前文件的路径。必须在 <code>Android.mk</code> 文件开头定义此变量。以下示例演示了如何定义此变量：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br></pre></td></tr></table></figure>

<p><code>CLEAR_VARS</code> 所指向的脚本不会清除此变量。因此，即使 <code>Android.mk</code> 文件描述了多个模块，您也只需定义它一次。</p>
<h5 id="LOCAL-MODULE"><a href="#LOCAL-MODULE" class="headerlink" title="LOCAL_MODULE"></a>LOCAL_MODULE</h5><p>此变量用于存储模块名称。指定的名称必须唯一，并且不得包含任何空格。必须在包含任何脚本（<code>CLEAR_VARS</code> 的脚本除外）之前定义此变量。无需添加 <code>lib</code> 前缀或者 <code>.so</code> 或 <code>.a</code> 文件扩展名；编译系统会自动进行这些修改。在整个 <code>Android.mk</code> 和 <a href="https://developer.android.com/ndk/guides/application_mk.html" target="_blank" rel="noopener"><code>Application.mk</code></a> 文件中，请通过未经修改的名称引用模块。例如，以下行会导致生成名为 <code>libfoo.so</code> 的共享库模块：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := <span class="string">"foo"</span></span><br></pre></td></tr></table></figure>

<p>如果希望生成的模块使用除“<code>lib</code> + <code>LOCAL_MODULE</code> 的值”以外的名称，您可使用 <code>LOCAL_MODULE_FILENAME</code> 变量为生成的模块指定自己选择的名称。</p>
<h5 id="LOCAL-MODULE-FILENAME"><a href="#LOCAL-MODULE-FILENAME" class="headerlink" title="LOCAL_MODULE_FILENAME"></a>LOCAL_MODULE_FILENAME</h5><p>此可选变量使您能够替换编译系统为其生成的文件默认使用的名称。例如，如果 <code>LOCAL_MODULE</code> 的名称为 <code>foo</code>，您可以强制系统将它生成的文件命名为 <code>libnewfoo</code>。以下示例演示了如何完成此操作：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := foo</span><br><span class="line">    LOCAL_MODULE_FILENAME := libnewfoo</span><br></pre></td></tr></table></figure>

<p>对于共享库模块，此示例将生成一个名为 <code>libnewfoo.so</code> 的文件。</p>
<p><strong>注意</strong>：您无法替换文件路径或文件扩展名。</p>
<h5 id="LOCAL-SRC-FILES"><a href="#LOCAL-SRC-FILES" class="headerlink" title="LOCAL_SRC_FILES"></a>LOCAL_SRC_FILES</h5><p>此变量包含编译系统生成模块时所用的源文件列表。只列出编译系统实际传递到编译器的文件，因为编译系统会自动计算所有相关的依赖关系。请注意，您可以使用相对（相对于 <code>LOCAL_PATH</code>）和绝对文件路径。</p>
<p>建议避免使用绝对文件路径；相对路径可以提高 <code>Android.mk</code> 文件的移植性。</p>
<p><strong>注意</strong>：务必在编译文件中使用 Unix 样式的正斜杠 (/)。编译系统无法正确处理 Windows 样式的反斜杠 ()。</p>
<h5 id="LOCAL-CPP-EXTENSION"><a href="#LOCAL-CPP-EXTENSION" class="headerlink" title="LOCAL_CPP_EXTENSION"></a>LOCAL_CPP_EXTENSION</h5><p>可以使用此可选变量为 C++ 源文件指明 <code>.cpp</code> 以外的文件扩展名。例如，以下行将扩展名更改为 <code>.cxx</code>。（设置必须包含点。）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_EXTENSION := .cxx</span><br></pre></td></tr></table></figure>

<p>您可以使用此变量指定多个扩展名。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_EXTENSION := .cxx .cpp .cc</span><br></pre></td></tr></table></figure>

<h5 id="LOCAL-CPP-FEATURES"><a href="#LOCAL-CPP-FEATURES" class="headerlink" title="LOCAL_CPP_FEATURES"></a>LOCAL_CPP_FEATURES</h5><p>您可使用此可选变量指明您的代码依赖于特定 C++ 功能。它会在编译过程中启用正确的编译器标记和链接器标记。对于预编译二进制文件，此变量还会声明二进制文件依赖于哪些功能，从而确保最终链接正常运行。建议您使用此变量，而不要直接在 <code>LOCAL_CPPFLAGS</code> 定义中启用 <code>-frtti</code> 和 <code>-fexceptions</code>。</p>
<p>使用此变量可让编译系统对每个模块使用适当的标记。使用 <code>LOCAL_CPPFLAGS</code> 会导致编译器将所有指定的标记用于所有模块，而不管实际需求如何。</p>
<p>例如，要指明您的代码使用 RTTI（运行时类型信息），请输入：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_FEATURES := rtti</span><br></pre></td></tr></table></figure>

<p>要指明您的代码使用 C++ 异常，请输入：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_FEATURES := exceptions</span><br></pre></td></tr></table></figure>

<p>您还可以为此变量指定多个值。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_FEATURES := rtti features</span><br></pre></td></tr></table></figure>

<p>描述值的顺序无关紧要。</p>
<h5 id="LOCAL-C-INCLUDES"><a href="#LOCAL-C-INCLUDES" class="headerlink" title="LOCAL_C_INCLUDES"></a>LOCAL_C_INCLUDES</h5><p>可以使用此可选变量指定相对于 NDK <code>root</code> 目录的路径列表，以便在编译所有源文件（C、C++ 和 Assembly）时添加到 include 搜索路径。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_C_INCLUDES := sources/foo</span><br></pre></td></tr></table></figure>

<p>或者甚至：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_C_INCLUDES := <span class="variable">$(LOCAL_PATH)</span>/&lt;subdirectory&gt;/foo</span><br></pre></td></tr></table></figure>

<p>请在通过 <code>LOCAL_CFLAGS</code> 或 <code>LOCAL_CPPFLAGS</code> 设置任何对应的包含标记前定义此变量。</p>
<p>在使用 ndk-gdb 启动原生调试时，编译系统也会自动使用 <code>LOCAL_C_INCLUDES</code> 路径。</p>
<h5 id="LOCAL-CFLAGS"><a href="#LOCAL-CFLAGS" class="headerlink" title="LOCAL_CFLAGS"></a>LOCAL_CFLAGS</h5><p>此可选变量用于设置在编译 C 和 C++ 源文件时编译系统要传递的编译器标记。这样，您就可以指定额外的宏定义或编译选项。可以使用 <code>LOCAL_CPPFLAGS</code> 仅为 C++ 指定标记。</p>
<p>请勿尝试在 <code>Android.mk</code> 文件中更改优化/调试级别。编译系统可以使用 [pplication.mk] 文件中的相关信息自动处理此设置。这样，编译系统就可以生成供调试期间使用的有用数据文件。</p>
<p>您可通过输入以下代码指定额外的 include 路径：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CFLAGS += -I&lt;path&gt;,</span><br></pre></td></tr></table></figure>

<p>但是，最好使用 <code>LOCAL_C_INCLUDES</code>，因为这样也可以使用可用于 ndk-gdb 原生调试的路径。</p>
<h5 id="LOCAL-CPPFLAGS"><a href="#LOCAL-CPPFLAGS" class="headerlink" title="LOCAL_CPPFLAGS"></a>LOCAL_CPPFLAGS</h5><p>只编译 C++ 源文件时将传递的一组可选编译器标记。它们将出现在编译器命令行中的 <code>LOCAL_CFLAGS</code> 后面。使用 <code>LOCAL_CFLAGS</code> 为 C 和 C++ 指定标记。</p>
<h5 id="LOCAL-STATIC-LIBRARIES"><a href="#LOCAL-STATIC-LIBRARIES" class="headerlink" title="LOCAL_STATIC_LIBRARIES"></a>LOCAL_STATIC_LIBRARIES</h5><p>此变量用于存储当前模块依赖的静态库模块列表。</p>
<p>如果当前模块是共享库或可执行文件，此变量将强制这些库链接到生成的二进制文件。</p>
<p>如果当前模块是静态库，此变量只是指出依赖于当前模块的其他模块也会依赖于列出的库。</p>
<h5 id="LOCAL-SHARED-LIBRARIES"><a href="#LOCAL-SHARED-LIBRARIES" class="headerlink" title="LOCAL_SHARED_LIBRARIES"></a>LOCAL_SHARED_LIBRARIES</h5><p>此变量会列出此模块在运行时依赖的共享库模块。此信息是链接时必需的信息，用于将相应的信息嵌入到生成的文件中。</p>
<h5 id="LOCAL-WHOLE-STATIC-LIBRARIES"><a href="#LOCAL-WHOLE-STATIC-LIBRARIES" class="headerlink" title="LOCAL_WHOLE_STATIC_LIBRARIES"></a>LOCAL_WHOLE_STATIC_LIBRARIES</h5><p>此变量是 <code>LOCAL_STATIC_LIBRARIES</code> 的变体，表示链接器应将相关的库模块视为完整归档。要详细了解完整归档，请参阅 <a href="http://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html" target="_blank" rel="noopener">GNU ld 文档</a>的 <code>--whole-archive</code> 标记部分。</p>
<p>多个静态库之间存在循环依赖关系时，此变量很有用。使用此变量编译共享库时，它将强制编译系统将静态库中的所有对象文件添加到最终二进制文件。但是，生成可执行文件时不会发生这种情况。</p>
<h5 id="LOCAL-LDLIBS"><a href="#LOCAL-LDLIBS" class="headerlink" title="LOCAL_LDLIBS"></a>LOCAL_LDLIBS</h5><p>此变量列出了在编译共享库或可执行文件时使用的额外链接器标记。利用此变量，您可使用 <code>-l</code> 前缀传递特定系统库的名称。例如，以下示例指示链接器生成在加载时链接到 <code>/system/lib/libz.so</code> 的模块：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_LDLIBS := -lz</span><br></pre></td></tr></table></figure>

<p>如需了解此 NDK 版本中可以链接的公开系统库列表，请参阅 <a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="noopener">Android NDK 原生 API</a>。</p>
<p><strong>注意</strong>：如果为静态库定义此变量，编译系统会忽略此变量，并且 <code>ndk-build</code> 会显示一则警告。</p>
<h5 id="LOCAL-LDFLAGS"><a href="#LOCAL-LDFLAGS" class="headerlink" title="LOCAL_LDFLAGS"></a>LOCAL_LDFLAGS</h5><p>此变量列出了编译系统在编译共享库或可执行文件时使用的其他链接器标记。例如，要在 ARM/X86 上使用 <code>ld.bfd</code> 链接器：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_LDFLAGS += -fuse-ld=bfd</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果为静态库定义此变量，编译系统会忽略此变量，并且 ndk-build 会显示一则警告。</p>
<h5 id="LOCAL-ALLOW-UNDEFINED-SYMBOLS"><a href="#LOCAL-ALLOW-UNDEFINED-SYMBOLS" class="headerlink" title="LOCAL_ALLOW_UNDEFINED_SYMBOLS"></a>LOCAL_ALLOW_UNDEFINED_SYMBOLS</h5><p>默认情况下，如果编译系统在尝试编译共享库时遇到未定义的引用，将会抛出“未定义的符号”错误。此错误可帮助您捕获源代码中的错误。</p>
<p>要停用此检查，请将此变量设置为 <code>true</code>。请注意，此设置可能会导致共享库在运行时加载。</p>
<p><strong>注意</strong>：如果为静态库定义此变量，编译系统会忽略此变量，并且 ndk-build 会显示一则警告。</p>
<h5 id="LOCAL-ARM-MODE"><a href="#LOCAL-ARM-MODE" class="headerlink" title="LOCAL_ARM_MODE"></a>LOCAL_ARM_MODE</h5><p>默认情况下，编译系统会在 thumb 模式下生成 ARM 目标二进制文件，其中每条指令都是 16 位宽，并与 <code>thumb/</code> 目录中的 STL 库关联。将此变量定义为 <code>arm</code> 会强制编译系统在 32 位 <code>arm</code> 模式下生成模块的对象文件。以下示例演示了如何执行此操作：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_ARM_MODE := arm</span><br></pre></td></tr></table></figure>

<p>您也可以对源文件名附加 <code>.arm</code> 后缀，指示编译系统在 <code>arm</code> 模式下仅编译特定的源文件。例如，以下示例指示编译系统在 ARM 模式下始终编译 <code>bar.c</code>，但根据 <code>LOCAL_ARM_MODE</code> 的值编译 <code>foo.c</code>。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES := foo.c bar.c.arm</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：您也可以在 <a href="https://developer.android.com/ndk/guides/application_mk.html" target="_blank" rel="noopener"><code>Application.mk</code></a> 文件中将 <code>APP_OPTIM</code> 设置为 <code>debug</code>，以强制编译系统生成 ARM 二进制文件。指定 <code>debug</code> 会强制执行 ARM 编译，因为工具链调试程序无法正确处理 Thumb 代码。</p>
<h5 id="LOCAL-ARM-NEON"><a href="#LOCAL-ARM-NEON" class="headerlink" title="LOCAL_ARM_NEON"></a>LOCAL_ARM_NEON</h5><p>此变量仅在以 <code>armeabi-v7a</code> ABI 为目标时才有意义。它允许在 C 和 C++ 源代码中使用 ARM Advanced SIMD (NEON) 编译器内建函数，以及在 Assembly 文件中使用 NEON 指令。</p>
<p>请注意，并非所有基于 ARMv7 的 CPU 都支持 NEON 扩展指令集。因此，必须执行运行时检测，以便在运行时安全地使用此代码。详情请参阅 <a href="https://developer.android.com/ndk/guides/cpu-arm-neon.html" target="_blank" rel="noopener">NEON 支持</a>和 <a href="https://developer.android.com/ndk/guides/cpu-features.html" target="_blank" rel="noopener">cpufeatures</a> 库。</p>
<p>此外，您也可以使用 <code>.neon</code> 后缀，指定编译系统仅以 NEON 支持编译特定源文件。在以下示例中，编译系统以 Thumb 和 NEON 支持编译 <code>foo.c</code>，以 Thumb 支持编译 <code>bar.c</code>，并以 ARM 和 NEON 支持编译 <code>zoo.c</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES = foo.c.neon bar.c zoo.c.arm.neon</span><br></pre></td></tr></table></figure>

<p>如果同时使用这两个后缀，则 <code>.arm</code> 必须在 <code>.neon</code> 前面。</p>
<h5 id="LOCAL-DISABLE-FORMAT-STRING-CHECKS"><a href="#LOCAL-DISABLE-FORMAT-STRING-CHECKS" class="headerlink" title="LOCAL_DISABLE_FORMAT_STRING_CHECKS"></a>LOCAL_DISABLE_FORMAT_STRING_CHECKS</h5><p>默认情况下，编译系统会在编译代码时保护格式字符串。这样的话，如果 <code>printf</code> 样式的函数中使用了非常量格式的字符串，就会强制引发编译器错误。此保护默认启用，但您也可通过将此变量的值设置为 <code>true</code> 将其停用。如果没有必要的原因，我们不建议停用。</p>
<h5 id="LOCAL-EXPORT-CFLAGS"><a href="#LOCAL-EXPORT-CFLAGS" class="headerlink" title="LOCAL_EXPORT_CFLAGS"></a>LOCAL_EXPORT_CFLAGS</h5><p>此变量用于记录一组 C/C++ 编译器标记，这些标记将添加到通过 <code>LOCAL_STATIC_LIBRARIES</code> 或 <code>LOCAL_SHARED_LIBRARIES</code> 变量使用此模块的任何其他模块的 <code>LOCAL_CFLAGS</code> 定义中。</p>
<p>例如，假设有下面这一对模块：<code>foo</code> 和 <code>bar</code>，bar 依赖于 <code>foo</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">    LOCAL_MODULE := foo</span><br><span class="line">    LOCAL_SRC_FILES := foo/foo.c</span><br><span class="line">    LOCAL_EXPORT_CFLAGS := -DFOO=1</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_LIBRARY)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">    LOCAL_MODULE := bar</span><br><span class="line">    LOCAL_SRC_FILES := bar.c</span><br><span class="line">    LOCAL_CFLAGS := -DBAR=2</span><br><span class="line">    LOCAL_STATIC_LIBRARIES := foo</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p>在此例中，编译系统在编译 <code>bar.c</code> 时会向编译器传递 <code>-DFOO=1</code> 和 <code>-DBAR=2</code> 标记。它还会在模块的 <code>LOCAL_CFLAGS</code> 前面加上导出的标记，以便您轻松进行替换。</p>
<p>此外，模块之间的关系也具有传递性：如果 <code>zoo</code> 依赖于 <code>bar</code>，而后者依赖于 <code>foo</code>，那么 <code>zoo</code> 也会继承从 <code>foo</code> 导出的所有标记。</p>
<p>最后，编译系统在执行局部编译时（即，编译要导出标记的模块时），不使用导出的标记。因此，在上面的示例中，编译 <code>foo/foo.c</code> 时不会将 <code>-DFOO=1</code> 传递到编译器。要执行局部编译，请改用 <code>LOCAL_CFLAGS</code>。</p>
<h5 id="LOCAL-EXPORT-CPPFLAGS"><a href="#LOCAL-EXPORT-CPPFLAGS" class="headerlink" title="LOCAL_EXPORT_CPPFLAGS"></a>LOCAL_EXPORT_CPPFLAGS</h5><p>此变量与 <code>LOCAL_EXPORT_CFLAGS</code> 相同，但仅适用于 C++ 标记。</p>
<h5 id="LOCAL-EXPORT-C-INCLUDES"><a href="#LOCAL-EXPORT-C-INCLUDES" class="headerlink" title="LOCAL_EXPORT_C_INCLUDES"></a>LOCAL_EXPORT_C_INCLUDES</h5><p>此变量与 <code>LOCAL_EXPORT_CFLAGS</code> 相同，但适用于 C include 路径。例如，当 <code>bar.c</code> 需要包含模块 <code>foo</code> 的头文件时，此变量很有用。</p>
<h5 id="LOCAL-EXPORT-LDFLAGS"><a href="#LOCAL-EXPORT-LDFLAGS" class="headerlink" title="LOCAL_EXPORT_LDFLAGS"></a>LOCAL_EXPORT_LDFLAGS</h5><p>此变量与 <code>LOCAL_EXPORT_CFLAGS</code> 相同，但适用于链接器标记。</p>
<h5 id="LOCAL-EXPORT-LDLIBS"><a href="#LOCAL-EXPORT-LDLIBS" class="headerlink" title="LOCAL_EXPORT_LDLIBS"></a>LOCAL_EXPORT_LDLIBS</h5><p>此变量与 <code>LOCAL_EXPORT_CFLAGS</code> 相同，告诉编译系统将特定系统库的名称传递给编译器。请在您指定的每个库名称前附加 <code>-l</code>。</p>
<p>请注意，编译系统会将导入的链接器标记附加到模块的 <code>LOCAL_LDLIBS</code> 变量值上。其原因在于 Unix 链接器的工作方式。</p>
<p>当模块 <code>foo</code> 是静态库并且具有依赖于系统库的代码时，此变量通常很有用。然后，您可以使用 <code>LOCAL_EXPORT_LDLIBS</code> 导出依赖关系。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">    LOCAL_MODULE := foo</span><br><span class="line">    LOCAL_SRC_FILES := foo/foo.c</span><br><span class="line">    LOCAL_EXPORT_LDLIBS := -llog</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_LIBRARY)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">    LOCAL_MODULE := bar</span><br><span class="line">    LOCAL_SRC_FILES := bar.c</span><br><span class="line">    LOCAL_STATIC_LIBRARIES := foo</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，编译系统在编译 <code>libbar.so</code> 时，在链接器命令的末尾指定了 <code>-llog</code>。这样就会告知链接器，由于 <code>libbar.so</code> 依赖于 <code>foo</code>，因此它也依赖于系统日志记录库。</p>
<h5 id="LOCAL-SHORT-COMMANDS"><a href="#LOCAL-SHORT-COMMANDS" class="headerlink" title="LOCAL_SHORT_COMMANDS"></a>LOCAL_SHORT_COMMANDS</h5><p>当模块有很多源文件和/或依赖的静态或共享库时，请将此变量设置为 <code>true</code>。这样会强制编译系统将 <code>@</code> 语法用于包含中间对象文件或链接库的归档。</p>
<p>此功能在 Windows 上可能很有用，在 Windows 上，命令行最多只接受 8191 个字符，这对于复杂的项目来说可能太少。它还会影响个别源文件的编译，而且将几乎所有编译器标记都放在列表文件内。</p>
<p>请注意，<code>true</code> 以外的任何值都将恢复为默认行为。您也可以在 <a href="https://developer.android.com/ndk/guides/application_mk.html" target="_blank" rel="noopener"><code>Application.mk</code></a> 文件中定义 <code>APP_SHORT_COMMANDS</code>，以对项目中的所有模块强制实施此行为。</p>
<p>不建议默认启用此功能，因为它会减慢编译速度。</p>
<h5 id="LOCAL-THIN-ARCHIVE"><a href="#LOCAL-THIN-ARCHIVE" class="headerlink" title="LOCAL_THIN_ARCHIVE"></a>LOCAL_THIN_ARCHIVE</h5><p>编译静态库时，请将此变量设置为 <code>true</code>。这样会生成一个<strong>瘦归档</strong>，即一个库文件，其中不含对象文件，而只包含它通常包含的实际对象的文件路径。</p>
<p>这对于减小编译输出的大小非常有用。但缺点是，这样的库无法移至其他位置（其中的所有路径都是相对路径）。</p>
<p>有效值为 <code>true</code>、<code>false</code> 或空白。您可在 <a href="https://developer.android.com/ndk/guides/application_mk.html" target="_blank" rel="noopener"><code>Application.mk</code></a> 文件中通过 <code>APP_THIN_ARCHIVE</code> 变量设置默认值。</p>
<p><strong>注意</strong>：在非静态库模块或预编译的静态库模块中，将会忽略此变量。</p>
<h5 id="LOCAL-FILTER-ASM"><a href="#LOCAL-FILTER-ASM" class="headerlink" title="LOCAL_FILTER_ASM"></a>LOCAL_FILTER_ASM</h5><p>请将此变量定义为一个 shell 命令，供编译系统用于过滤根据您为 <code>LOCAL_SRC_FILES</code> 指定的文件提取或生成的汇编文件。定义此变量会导致发生以下情况：</p>
<ol>
<li>编译系统从任何 C 或 C++ 源文件生成临时汇编文件，而不是将它们编译到对象文件中。</li>
<li>编译系统在任何临时汇编文件以及 <code>LOCAL_SRC_FILES</code> 中所列任何汇编文件的 <code>LOCAL_FILTER_ASM</code> 中执行 shell 命令，因此会生成另一个临时汇编文件。</li>
<li>编译系统将这些过滤的汇编文件编译到对象文件中。</li>
</ol>
<p>例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES  := foo.c bar.S</span><br><span class="line">    LOCAL_FILTER_ASM :=</span><br><span class="line"></span><br><span class="line">    foo.c --1--&gt; $OBJS_DIR/foo.S.original --2--&gt; $OBJS_DIR/foo.S --3--&gt; $OBJS_DIR/foo.o</span><br><span class="line">    bar.S                                 --2--&gt; $OBJS_DIR/bar.S --3--&gt; $OBJS_DIR/bar.o</span><br></pre></td></tr></table></figure>

<p>“1”对应于编译器，“2”对应于过滤器，“3”对应于汇编程序。过滤器必须是一个独立的 shell 命令，它接受输入文件名作为第一个参数，接受输出文件名作为第二个参数。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myasmfilter $OBJS_DIR/foo.S.original $OBJS_DIR/foo.S</span><br><span class="line">    myasmfilter bar.S $OBJS_DIR/bar.S</span><br></pre></td></tr></table></figure>

<h3 id="NDK提供的函数宏"><a href="#NDK提供的函数宏" class="headerlink" title="NDK提供的函数宏"></a>NDK提供的函数宏</h3><p>本部分介绍了 NDK 提供的 GNU Make 函数宏。使用 <code>$(call &lt;function&gt;)</code> 可以对这些宏进行求值；它们将返回文本信息。</p>
<h5 id="my-dir"><a href="#my-dir" class="headerlink" title="my-dir"></a>my-dir</h5><p>这个宏返回最后包含的 makefile 的路径，通常是当前 <code>Android.mk</code> 的目录。<code>my-dir</code> 可用于在 <code>Android.mk</code> 文件的开头定义 <code>LOCAL_PATH</code>。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br></pre></td></tr></table></figure>

<p>由于 GNU Make 的工作方式，这个宏实际返回的是编译系统解析编译脚本时包含的最后一个 makefile 的路径。因此，包含其他文件后就不应调用 <code>my-dir</code>。</p>
<p>例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... declare one module</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(LOCAL_PATH)</span>/foo/`Android.mk`</span><br><span class="line"></span><br><span class="line">    LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... declare another module</span></span><br></pre></td></tr></table></figure>

<p>该示例的问题在于，对 <code>my-dir</code> 的第二次调用将 <code>LOCAL_PATH</code> 定义为 <code>$PATH/foo</code>，而不是 <code>$PATH</code>，因为这是其最近的 include 所指向的位置。</p>
<p>在 <code>Android.mk</code> 文件中的所有其他内容后添加额外的 include 可避免此问题。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... declare one module</span></span><br><span class="line"></span><br><span class="line">    LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... declare another module</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># extra includes at the end of the Android.mk file</span></span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(LOCAL_PATH)</span>/foo/Android.mk</span><br></pre></td></tr></table></figure>

<p>如果以这种方式构造文件不可行，请将第一个 <code>my-dir</code> 调用的值保存到另一个变量中。例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MY_LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line">    LOCAL_PATH := <span class="variable">$(MY_LOCAL_PATH)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... declare one module</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$(LOCAL_PATH)</span>/foo/`Android.mk`</span><br><span class="line"></span><br><span class="line">    LOCAL_PATH := <span class="variable">$(MY_LOCAL_PATH)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... declare another module</span></span><br></pre></td></tr></table></figure>

<h5 id="all-subdir-makefiles"><a href="#all-subdir-makefiles" class="headerlink" title="all-subdir-makefiles"></a>all-subdir-makefiles</h5><p>返回位于当前 <code>my-dir</code> 路径所有子目录中的 <code>Android.mk</code> 文件列表。</p>
<p>利用此函数，您可以为编译系统提供深度嵌套的源目录层次结构。默认情况下，NDK 只在 <code>Android.mk</code> 文件所在的目录中查找文件。</p>
<h5 id="this-makefile"><a href="#this-makefile" class="headerlink" title="this-makefile"></a>this-makefile</h5><p>返回当前 makefile（编译系统从中调用函数）的路径。</p>
<h5 id="parent-makefile"><a href="#parent-makefile" class="headerlink" title="parent-makefile"></a>parent-makefile</h5><p>返回包含树中父 makefile 的路径（包含当前 makefile 的 makefile 的路径）。</p>
<h5 id="grand-parent-makefile"><a href="#grand-parent-makefile" class="headerlink" title="grand-parent-makefile"></a>grand-parent-makefile</h5><p>返回包含树中祖父 makefile 的路径（包含当前父 makefile 的 makefile 的路径）。</p>
<h5 id="import-module"><a href="#import-module" class="headerlink" title="import-module"></a>import-module</h5><p>此函数用于按模块名称查找和包含模块的 <code>Android.mk</code> 文件。典型的示例如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> import-module,&lt;name&gt;)</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，编译系统在 <code>NDK_MODULE_PATH</code> 环境变量所引用的目录列表中查找具有 <code>&lt;name&gt;</code> 标记的模块，并且自动包含其 <code>Android.mk</code> 文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/09/05/NDK开发编译知识点汇集-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/NDK开发编译知识点汇集-4/" class="post-title-link" itemprop="url">NDK开发编译知识点汇集[4]</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-05 10:29:27" itemprop="dateCreated datePublished" datetime="2019-09-05T10:29:27+08:00">2019-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 10:30:53" itemprop="dateModified" datetime="2019-12-31T10:30:53+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NDK/" itemprop="url" rel="index">
                    <span itemprop="name">NDK</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android-NDK-开发指南"><a href="#Android-NDK-开发指南" class="headerlink" title="Android NDK 开发指南"></a>Android NDK 开发指南</h2><p>Android NDK 是一组使您能将 C 或 C++（“原生代码”）嵌入到 Android 应用中的工具。能够在 Android 应用中使用原生代码对于想执行以下一项或多项操作的开发者特别有用：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/09/05/NDK开发编译知识点汇集-4/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/09/02/NDK开发JNI起步-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/02/NDK开发JNI起步-3/" class="post-title-link" itemprop="url">NDK开发JNI起步[3]</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-02 19:41:32" itemprop="dateCreated datePublished" datetime="2019-09-02T19:41:32+08:00">2019-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 10:30:53" itemprop="dateModified" datetime="2019-12-31T10:30:53+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NDK/" itemprop="url" rel="index">
                    <span itemprop="name">NDK</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JNI/" itemprop="url" rel="index">
                    <span itemprop="name">JNI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="采用Android-studio进行开发"><a href="#采用Android-studio进行开发" class="headerlink" title="采用Android studio进行开发"></a>采用Android studio进行开发</h3><ol>
<li><p>首先要集成NDK开发环境 参见 <a href="https://developer.android.google.cn/ndk/guides?hl=zh_cn" target="_blank" rel="noopener">“NDK Android studio 环境集成”</a></p>
</li>
<li><p>按照如下流程操作，新建一个工程项目：</p>
<blockquote>
<p>as-&gt;File-&gt;new Project-&gt;Phone and Tablet-&gt;Native C++ &gt; next &gt; C++ support &gt; finish</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/09/02/NDK开发JNI起步-3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jrhlive.com/2019/08/30/Andorid优秀博客推荐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jiarh">
      <meta itemprop="description" content="coding change the world .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="STAY HUNGRY. STAY FOOLISH.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/30/Andorid优秀博客推荐/" class="post-title-link" itemprop="url">Andorid优秀博客推荐</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-30 18:21:17" itemprop="dateCreated datePublished" datetime="2019-08-30T18:21:17+08:00">2019-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 10:30:53" itemprop="dateModified" datetime="2019-12-31T10:30:53+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/flutter/" itemprop="url" rel="index">
                    <span itemprop="name">flutter</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h1><ol>
<li><a href="https://juejin.im/post/5d2178ede51d4556d86c7b36" target="_blank" rel="noopener">Android 混合Flutter之源码集成方式</a></li>
<li><a href="https://www.jianshu.com/p/cf7cf1b640ee" target="_blank" rel="noopener">Flutter页面嵌入Android Activity中</a></li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/08/30/Andorid优秀博客推荐/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiarh</p>
  <div class="site-description" itemprop="description">coding change the world .</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiarh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
